import {
  VaButton,
  VaButtonToggle,
  VaCard,
  VaCheckbox,
  VaColorIndicator,
  VaCounter,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaIcon,
  VaInput,
  VaScrollContainer,
  VaSelect,
  VaTab,
  VaTabs,
  VaTextarea,
  _sfc_main4 as _sfc_main,
  createVuestic,
  useColors,
  useToast
} from "./chunk-TUJFDQPQ.js";
import "./chunk-2CW3FFQV.js";
import {
  Fragment,
  Teleport,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  isVNode,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  openBlock,
  popScopeId,
  pushScopeId,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRef,
  unref,
  useModel,
  vModelText,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withModifiers
} from "./chunk-APNVCS7Z.js";
import "./chunk-UVKRO5ER.js";

// node_modules/@vuestic/compiler/dist/devtools/client/vuestic-devtools.es.js
import "/media/debian/6052C6C057AECFE2/Trabajo/Greenborn/vuestic-admin/node_modules/@vuestic/compiler/dist/devtools/client/style.css";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var useEvent = (event, handler, options = {}) => {
  onMounted(() => {
    window.addEventListener(event, handler, options);
  });
  onBeforeUnmount(() => {
    window.removeEventListener(event, handler, options);
  });
};
var outlines = [];
var useOutlines = () => {
  return () => {
    outlines.forEach((recalculate) => recalculate());
  };
};
var useOutline = (recalculate) => {
  onMounted(() => {
    outlines.push(recalculate);
  });
  onBeforeUnmount(() => {
    const index = outlines.indexOf(recalculate);
    if (index !== -1) {
      outlines.splice(index, 1);
    }
  });
};
var useMutationObserver = (target, callback) => {
  let observer = new MutationObserver(callback);
  watch(target, (newValue, oldValue) => {
    if (oldValue) {
      observer.disconnect();
    }
    if (newValue) {
      observer.observe(newValue, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  });
};
var _sfc_main$u = defineComponent({
  __name: "Outline",
  props: {
    node: {},
    color: { default: "outlinePrimary" },
    background: { default: "transparent" },
    dashed: { type: Boolean, default: false },
    thickness: { default: 1 }
  },
  setup(__props) {
    const props = __props;
    const outlineEl = ref();
    const { getColor } = useColors();
    const updateSize = () => {
      if (!props.node) {
        return;
      }
      if (!outlineEl.value) {
        return;
      }
      const { top, left, width, height } = props.node.getBoundingClientRect();
      outlineEl.value.style.top = `${top}px`;
      outlineEl.value.style.left = `${left}px`;
      outlineEl.value.style.width = `${width}px`;
      outlineEl.value.style.height = `${height}px`;
    };
    watchEffect(updateSize);
    let prevTimeout;
    useEvent("resize", () => {
      clearTimeout(prevTimeout);
      prevTimeout = setTimeout(updateSize, 0);
    });
    useOutline(updateSize);
    useMutationObserver(toRef(props, "node"), updateSize);
    return (_ctx, _cache) => {
      return _ctx.node ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-devtools-outline",
        ref_key: "outlineEl",
        ref: outlineEl,
        style: normalizeStyle({
          borderColor: unref(getColor)(_ctx.color),
          borderStyle: _ctx.dashed ? "dashed" : "solid",
          borderWidth: `${_ctx.thickness}px`,
          background: unref(getColor)(_ctx.background)
        })
      }, null, 4)) : createCommentVNode("", true);
    };
  }
});
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
var Outline = _export_sfc(_sfc_main$u, [["__scopeId", "data-v-e435855f"]]);
var _sfc_main$t = {};
var _hoisted_1$i = { class: "va-devtools-overlay" };
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$i);
}
var Overlay = _export_sfc(_sfc_main$t, [["render", _sfc_render], ["__scopeId", "data-v-1a4b2b08"]]);
var getTagContent = (source) => {
  if (source.endsWith("/>")) {
    return source.slice(1, -2);
  }
  return source.slice(1, -1);
};
var parseOpenTag = (source) => {
  source = source.trim().replace(/\n/g, "");
  let tagName = "";
  const attributes = {};
  let tagContent = getTagContent(source);
  if (!tagContent.includes(" ")) {
    tagName = tagContent;
    return { tagName, attributes };
  }
  tagContent += " ";
  let i = 0;
  while (tagContent[i] !== " ") {
    tagName += tagContent[i];
    i++;
  }
  i++;
  let key2 = "";
  let value = null;
  let isInQuotes = false;
  while (i < tagContent.length) {
    if (tagContent[i] === '"') {
      isInQuotes = !isInQuotes;
      i++;
      continue;
    }
    if (tagContent[i] === " " && !isInQuotes) {
      if (key2 !== "") {
        attributes[key2] = value;
      }
      key2 = "";
      value = null;
      i++;
      continue;
    }
    if (tagContent[i] === "=") {
      i++;
      value = "";
      continue;
    }
    if (isInQuotes) {
      value += tagContent[i];
    } else {
      key2 += tagContent[i];
    }
    i++;
  }
  return { tagName, attributes };
};
var superTrim = (content) => {
  return content.replace(/\n/gm, "").trim();
};
var isValidContent = (content) => {
  return superTrim(content) !== "";
};
var parseTokens = (source) => {
  let current = 0;
  const tokens = [];
  while (current < source.length) {
    const startTag = source.indexOf("<", current);
    if (startTag === -1) {
      break;
    }
    const endTag = source.indexOf(">", startTag);
    if (endTag === -1) {
      break;
    }
    const tagContent = source.slice(startTag, endTag + 1);
    const isSelfClosing = tagContent.endsWith("/>");
    const isClosingTag = tagContent.startsWith("</");
    const content = source.slice(current, startTag);
    if (isValidContent(content)) {
      tokens.push({
        type: "content",
        loc: {
          start: { offset: current },
          end: { offset: startTag },
          source: source.slice(current, startTag)
        }
      });
    }
    if (isSelfClosing) {
      tokens.push({
        type: "tag:self-closing",
        loc: {
          start: { offset: startTag },
          end: { offset: endTag + 1 },
          source: tagContent
        },
        tag: tagContent.slice(1, -2)
      });
    } else if (isClosingTag) {
      tokens.push({
        type: "tag:close",
        loc: {
          start: { offset: startTag },
          end: { offset: endTag + 1 },
          source: tagContent
        },
        tag: tagContent.slice(2, -1)
      });
    } else {
      tokens.push({
        type: "tag:open",
        loc: {
          start: { offset: startTag },
          end: { offset: endTag + 1 },
          source: tagContent
        },
        tag: superTrim(tagContent.slice(1, -1).split(" ")[0])
      });
    }
    current = endTag + 1;
  }
  return tokens;
};
var tokensToTree = (tokens) => {
  const root2 = {
    type: "root",
    children: []
  };
  let parent = root2;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.type === "tag:open") {
      if (!parent.children || typeof parent.children === "string") {
        throw new Error("Unexpected error when parsing HTML");
      }
      const { attributes } = parseOpenTag(token.loc.source);
      const node = {
        type: "element",
        tag: token.tag,
        children: [],
        attributes,
        parent
      };
      parent.children.push(node);
      parent = node;
    }
    if (token.type === "tag:close") {
      if (!("parent" in parent)) {
        throw new Error("Closing tag without parent node");
      }
      parent = parent.parent;
    }
    if (token.type === "content") {
      if (!parent.children || typeof parent.children === "string") {
        throw new Error("Unexpected error when parsing HTML");
      }
      parent.children.push({
        type: "content",
        text: token.loc.source,
        parent
      });
    }
    if (token.type === "tag:self-closing") {
      if (!parent.children || typeof parent.children === "string") {
        throw new Error("Unexpected error when parsing HTML");
      }
      const { attributes, tagName } = parseOpenTag(token.loc.source);
      parent.children.push({
        type: "element",
        tag: tagName,
        children: [],
        attributes,
        parent
      });
    }
  }
  return root2;
};
var parseSource = (source) => {
  const tokens = parseTokens(source);
  const tree = tokensToTree(tokens);
  return tree;
};
var getVNodeComponent = (vNode) => {
  var _a;
  if (!vNode) return null;
  if (typeof vNode.type === "string") {
    return { name: vNode.type, props: {} };
  }
  if (typeof vNode.type === "object") {
    if ("__name" in vNode.type) {
      return {
        name: vNode.type.__name || void 0,
        props: vNode.type.props
      };
    }
    if ("name" in vNode.type) {
      return {
        name: vNode.type.name || void 0,
        props: vNode.props
      };
    }
  }
  return {
    name: ((_a = vNode.el) == null ? void 0 : _a.tagName) ?? "unknown",
    props: {}
  };
};
var useComponentMeta = (vNode) => {
  return computed(() => {
    var _a;
    return {
      type: (_a = vNode.value) == null ? void 0 : _a.type,
      ...getVNodeComponent(vNode.value)
    };
  });
};
var printSource = (source) => {
  let tabSize = 0;
  const printTabs = () => " ".repeat(tabSize);
  const print = (node) => {
    let result = "";
    for (const child of node.children) {
      if ("text" in child) {
        result += child.text.split("\n").filter((line) => line.trim() !== "").map((line) => printTabs() + line.trim()).join("\n") + "\n";
      } else {
        result += printTabs() + `<${child.tag}`;
        const attributesCount = Object.keys(child.attributes).length;
        if (attributesCount === 1) {
          const [key2, value] = Object.entries(child.attributes)[0];
          if (value === null) {
            result += ` ${key2}`;
          } else {
            result += ` ${key2}="${value}"`;
          }
        } else if (attributesCount > 1) {
          result += "\n";
          tabSize += 2;
          for (const [key2, value] of Object.entries(child.attributes)) {
            if (value === null) {
              result += printTabs() + ` ${key2}`;
            } else {
              result += printTabs() + ` ${key2}="${value}"`;
            }
            result += "\n";
          }
          tabSize -= 2;
          result += printTabs();
        }
        if (child.children.length === 0) {
          if (attributesCount <= 1) {
            result += " ";
          }
          result += "/>\n";
          continue;
        }
        result += ">\n";
        tabSize += 2;
        result += printTabs() + print(child).trim();
        tabSize -= 2;
        result += "\n" + printTabs() + `</${child.tag}>
`;
      }
    }
    return result;
  };
  if (source.type === "content") {
    return source.text;
  }
  return print(source);
};
var transformPropName = (name, type) => {
  switch (type) {
    case "attr":
      return name;
    case "bind":
      return `:${name}`;
    case "v-model":
      return `v-model:${name}`;
    case "event":
      return `@${name}`;
  }
};
var extractSlotName = (keys) => {
  for (const key2 of keys) {
    if (key2.startsWith("v-slot:")) {
      return key2.slice(7);
    }
    if (key2.startsWith("#")) {
      return key2.slice(1);
    }
  }
};
var removeDuplicatedAttributes = (attrs) => {
  Object.keys(attrs).forEach((attributeName, i, keys) => {
    const attributeNameNormalized = attributeName.replace(/^:|^v-model:|^v-bind:/, "");
    if (attributeNameNormalized === attributeName) {
      return;
    }
    if (keys.includes(attributeNameNormalized)) {
      delete attrs[attributeName];
    }
  });
  return attrs;
};
var useComponentCode = (source, vNode) => {
  const ast = computed(() => {
    if (!source.value) return null;
    try {
      return parseSource(source.value);
    } catch (e) {
      console.log(e);
      return null;
    }
  });
  const meta = useComponentMeta(vNode);
  const attributes = computed(() => {
    if (!ast.value) return null;
    const element2 = ast.value.children[0];
    if (!element2) return null;
    if (element2.type === "content") {
      return null;
    }
    return element2.attributes;
  });
  const slots = computed(() => {
    if (!ast.value) return null;
    const element2 = ast.value.children[0];
    if (element2.type === "content") {
      return [{ name: "default", text: element2.text }];
    }
    const slots2 = [];
    for (const child of element2.children) {
      if (child.type === "content") {
        slots2.push({ name: "default", text: child.text.trim() });
        continue;
      }
      if (child.tag === "template") {
        const slotName = extractSlotName(Object.keys(child.attributes));
        const slotText = child.children.length === 1 && child.children[0].type === "content" ? child.children[0].text : null;
        if (slotName && slotText) {
          slots2.push({ name: slotName, text: slotText.trim() });
        }
      }
    }
    return slots2;
  });
  const updateAttribute = (name, value, type = "attr") => {
    if (!ast.value) {
      throw new Error("Unable to update attribute: no AST available");
    }
    if (ast.value.children.length !== 1) {
      throw new Error("Unable to update attribute: multi-node");
    }
    const element2 = ast.value.children[0];
    if (element2.type === "content") {
      throw new Error("Unable to update attribute: content node can not have attributes");
    }
    const currentAttributesNames = Object.keys(element2.attributes);
    const newAttributes = currentAttributesNames.reduce((acc, attributeName) => {
      if (attributeName === name) {
        return acc;
      }
      acc[attributeName] = element2.attributes[attributeName];
      return acc;
    }, {});
    const newRoot = {
      type: "root",
      children: []
    };
    const propsMeta = meta.value.props;
    if (propsMeta && name in propsMeta) {
      const propMeta = propsMeta[name];
      if (propMeta.default === value && value !== void 0) {
        newRoot.children.push({
          ...element2,
          attributes: removeDuplicatedAttributes(newAttributes),
          parent: newRoot
        });
        return printSource(newRoot);
      }
    }
    const child = {
      ...element2,
      attributes: removeDuplicatedAttributes({
        ...newAttributes,
        [transformPropName(name, type)]: value
      }),
      parent: newRoot
    };
    if (value === void 0) {
      delete child.attributes[name];
    }
    newRoot.children.push(child);
    return printSource(newRoot);
  };
  const updateSlot = (name, value) => {
    if (!ast.value) {
      throw new Error("Unable to update slot: no AST available");
    }
    if (ast.value.children.length !== 1) {
      throw new Error("Unable to update slot: multi-node");
    }
    const element2 = ast.value.children[0];
    const newRoot = {
      type: "root",
      children: []
    };
    if (element2.type === "content") {
      if (name !== "default") {
        throw new Error("Unable to update slot: content node can only have default slot");
      }
      newRoot.children.push({
        type: "content",
        text: value,
        parent: newRoot
      });
      return printSource(newRoot);
    }
    const newChildren = element2.children.map((child) => {
      if (child.type === "content") {
        if (name === "default") {
          return {
            ...child,
            text: value
          };
        }
        return child;
      }
      if (child.tag === "template") {
        const slotName = extractSlotName(Object.keys(child.attributes));
        if (slotName === name) {
          return {
            ...child,
            children: [{ type: "content", text: value, parent: child }]
          };
        }
      }
      return child;
    });
    newRoot.children.push({
      ...element2,
      children: newChildren,
      parent: newRoot
    });
    return printSource(newRoot);
  };
  const appendChild = (code2) => {
    if (!ast.value) {
      throw new Error("Unable to append child: no AST available");
    }
    if (ast.value.children.length !== 1) {
      throw new Error("Unable to append child: multi-node");
    }
    const element2 = ast.value.children[0];
    const newRoot = {
      type: "root",
      children: []
    };
    if (element2.type === "content") {
      throw new Error("Unable to append child: content node can not have children");
    }
    const newChildren = [
      ...element2.children,
      {
        type: "content",
        text: code2,
        parent: element2
      }
    ];
    newRoot.children.push({
      ...element2,
      children: newChildren,
      parent: newRoot
    });
    return printSource(newRoot);
  };
  const isParsed = computed(() => {
    return attributes.value !== null && slots.value !== null && !source.isLoading && source.value !== null;
  });
  return {
    isParsed,
    meta,
    // ast,
    attributes,
    slots,
    updateAttribute,
    updateSlot,
    appendChild
  };
};
var PREFIX = "va";
var EDIT_MODE_CLASS = "va-edit-mode";
var API_PREFIX = "/vuestic-devtools-api";
var API_URL = new URL(import.meta.url).origin + API_PREFIX;
var getNodeSource = (q) => {
  return fetch(`${API_URL}/node-source?q=${q}`);
};
var setNodeSource = (q, source) => {
  return fetch(`${API_URL}/node-source?q=${q}`, {
    method: "PATCH",
    body: source
  });
};
var getVSCodePath = (q) => {
  return fetch(`${API_URL}/vscode-path?q=${q}`);
};
var deleteNodeSource = (q) => {
  return fetch(`${API_URL}/node-source?q=${q}`, {
    method: "DELETE"
  });
};
var getFileRelativePath = (q) => {
  return fetch(`${API_URL}/relative-file-path?q=${q}`);
};
var useAsyncComputed = (fn, defaultValue) => {
  const value = ref(defaultValue);
  const isLoading = ref(false);
  const error = ref(null);
  const load = async () => {
    try {
      isLoading.value = true;
      value.value = await fn();
    } catch (e) {
      if (e instanceof Error) {
        error.value = e;
      }
    } finally {
      isLoading.value = false;
    }
  };
  watchEffect(() => {
    load();
  });
  const comp = computed(() => {
    return value.value;
  });
  Object.defineProperty(comp, "loading", {
    get() {
      return isLoading.value;
    }
  });
  return comp;
};
var useComponentSource = (uid) => {
  const source = ref(null);
  const isSourceLoading = ref(false);
  const resetSource = () => {
    source.value = null;
  };
  const loadSource = async () => {
    if (!uid.value) {
      resetSource();
      return;
    }
    try {
      isSourceLoading.value = true;
      const response = await getNodeSource(uid.value);
      source.value = await response.text();
    } finally {
      isSourceLoading.value = false;
    }
  };
  const saveSource = async (source2) => {
    if (!uid.value) {
      throw new Error("Can not save source: no q available");
    }
    await setNodeSource(uid.value, source2);
    await loadSource();
  };
  const removeFromSource = async () => {
    if (!uid.value) {
      throw new Error("Can not delete source: no q available");
    }
    source.value = "";
    await deleteNodeSource(uid.value);
  };
  watch(uid, async () => {
    resetSource();
    loadSource();
  }, { immediate: true });
  const openInVSCode = async () => {
    if (!uid.value) {
      throw new Error("Can not open in VSCode: no q available");
    }
    const path = await (await getVSCodePath(uid.value)).text();
    fetch(`/__open-in-editor?file=${path}`);
  };
  const fileName = useAsyncComputed(async () => {
    if (!uid.value) {
      return null;
    }
    return await (await getFileRelativePath(uid.value)).text();
  }, "");
  return {
    content: source,
    get value() {
      return source.value;
    },
    get isLoading() {
      return isSourceLoading.value;
    },
    fileName,
    refresh: loadSource,
    update: saveSource,
    remove: removeFromSource,
    openInVSCode
  };
};
var defineGlobal = (composable) => {
  const result = composable();
  return () => result;
};
var selectedAppTreeItem = ref(null);
var useSelectedAppTreeItem = () => {
  return {
    selectedAppTreeItem,
    sameNodeItems: computed(() => {
      if (!selectedAppTreeItem.value) {
        return [];
      }
      const items = [];
      const walk = (tree) => {
        var _a, _b;
        for (const item of tree) {
          if ("text" in item) {
            continue;
          }
          if ((_a = item.el) == null ? void 0 : _a.isEqualNode(selectedAppTreeItem.value.el)) {
            items.push(item);
          }
          if ((_b = item.repeatedElements) == null ? void 0 : _b.some((el) => el.isEqualNode(selectedAppTreeItem.value.el))) {
            items.push(item);
          }
          walk(item.children);
        }
      };
      walk(_appTree.value);
      return items;
    }),
    selectAppTreeItem(search) {
      if (search === null) {
        selectedAppTreeItem.value = null;
        return;
      }
      const item = typeof search === "string" || search instanceof HTMLElement ? walkTree(search) : search;
      if (!item) {
        console.log(
          _appTree.value,
          search
        );
        throw new Error("Could not find item");
      }
      if ("text" in item) {
        throw new Error("Can not select text item");
      }
      selectedAppTreeItem.value = item;
    }
  };
};
var isDevtoolsComponent = (vnode) => {
  const el = vnode.el;
  if (!el) {
    return false;
  }
  if ("dataset" in el) {
    return Object.keys(el.dataset).includes(PREFIX);
  }
  return false;
};
var getItemName = (vnode) => {
  if (typeof vnode.type === "string") {
    return vnode.type;
  }
  if (typeof vnode.type === "object") {
    if ("name" in vnode.type) {
      return vnode.type.name;
    }
    if ("__name" in vnode.type) {
      return vnode.type.__name;
    }
  }
};
var getItemChildren = (vnode) => {
  if (vnode.component) {
    if (vnode.type.__hmrId) {
      return [vnode.component.subTree];
    }
    return getItemChildren(vnode.component.subTree);
  }
  if (Array.isArray(vnode.children)) {
    return vnode.children;
  }
  if (vnode.children === null) {
    return null;
  }
  if (typeof vnode.children === "object") {
    return null;
  }
  return [vnode.children];
};
var getAppTree = async () => {
  const app = document.querySelector("#app");
  if (!app) {
    throw new Error("App element not found when building app tree");
  }
  const traverseChildren = (vnode2) => {
    if (vnode2 === null) {
      return [];
    }
    if (Array.isArray(vnode2)) {
      return vnode2.filter((vnode3) => !!vnode3).map((vnode3) => {
        if (Array.isArray(vnode3)) {
          return traverseChildren(vnode3);
        }
        if (isVNode(vnode3)) {
          return traverse(vnode3);
        }
        return {
          text: String(vnode3)
        };
      }).flat();
    }
    return {
      text: String(vnode2)
    };
  };
  const traverse = (vnode2) => {
    var _a;
    if (vnode2.type === Fragment) {
      return traverseChildren(vnode2.children);
    }
    const name = getItemName(vnode2);
    if (!isDevtoolsComponent(vnode2)) {
      return traverseChildren(getItemChildren(vnode2));
    }
    const ids = vnode2.props && Object.keys(vnode2.props).filter((p2) => p2.startsWith(`data-${PREFIX}-`)).map((p2) => p2.replace(`data-`, ""));
    if (!ids) {
      return traverseChildren(getItemChildren(vnode2));
    }
    const removeInheritedId = (children) => {
      if (ids) {
        children.forEach((child) => {
          if ("ids" in child) {
            child.ids = child.ids.filter((id) => !ids.includes(id));
          }
        });
      }
      const grouped = [];
      children.forEach((child) => {
        if ("ids" in child) {
          const [id] = child.ids;
          const existing = grouped.find((group) => "ids" in group && group.ids.includes(id));
          if (!existing) {
            grouped.push(child);
          } else {
            existing.repeated = (existing.repeated || 1) + 1;
            existing.repeatedElements = existing.repeatedElements || [];
            existing.repeatedElements.push(child.el);
          }
        } else {
          grouped.push(child);
        }
      });
      return grouped;
    };
    return {
      ids: ids ?? [],
      el: vnode2.el,
      vnode: vnode2,
      name: name ?? "unknown",
      children: removeInheritedId(((_a = getItemChildren(vnode2)) == null ? void 0 : _a.map((child) => {
        if (Array.isArray(child)) {
          return traverseChildren(child);
        }
        if (isVNode(child)) {
          return traverse(child);
        }
        return {
          text: String(child)
        };
      }).flat()) ?? [])
    };
  };
  const getAppVNode = () => {
    return new Promise((resolve) => {
      if ("_vnode" in app) {
        return resolve(app._vnode);
      }
      requestAnimationFrame(async () => {
        resolve(await getAppVNode());
      });
    });
  };
  const vnode = await getAppVNode();
  return traverse(vnode);
};
var walkTree = (search, tree = appTree.value) => {
  var _a, _b, _c, _d;
  for (const item of tree) {
    if ("text" in item) {
      continue;
    }
    if (typeof search === "string") {
      if (item.ids.includes(search)) {
        return item;
      }
    } else if (search instanceof HTMLElement) {
      if ((_a = item.el) == null ? void 0 : _a.isEqualNode(search)) {
        return item;
      }
      if ((_b = item.repeatedElements) == null ? void 0 : _b.some((el) => el.isEqualNode(search))) {
        return item;
      }
    } else if ("name" in search) {
      const searchEl = search.el;
      const searchName = search.name;
      const isSameNode = ((_c = item.el) == null ? void 0 : _c.isEqualNode(searchEl)) || ((_d = item.repeatedElements) == null ? void 0 : _d.some((el) => el.isEqualNode(el)));
      const isSameName = item.name === searchName;
      if (isSameName && isSameNode) {
        return item;
      }
    }
    const child = walkTree(search, item.children);
    if (child) {
      return child;
    }
  }
  return null;
};
var appTree = ref([]);
var _appTree = appTree;
var useAppTree = () => {
  const { selectedAppTreeItem: selectedAppTreeItem2, sameNodeItems, selectAppTreeItem } = useSelectedAppTreeItem();
  const refresh = async () => {
    const oldSelectedAppTreeItem = selectedAppTreeItem2.value;
    const tree = await getAppTree();
    if (!Array.isArray(tree)) {
      appTree.value = [tree];
    } else {
      appTree.value = tree;
    }
    if (oldSelectedAppTreeItem) {
      const selectedNode = walkTree(oldSelectedAppTreeItem);
      if (selectedNode && "el" in selectedNode) {
        selectedAppTreeItem2.value = selectedNode;
      }
    }
  };
  onMounted(() => {
    if (appTree.value.length === 0) {
      refresh();
    }
  });
  return {
    appTree,
    refresh,
    selectAppTreeItem,
    selectedAppTreeItem: selectedAppTreeItem2,
    sameNodeItems
  };
};
var findPropFromAttributes = (attributes, propName) => {
  const possibleNames = [
    propName,
    `:${propName}`,
    `v-bind:${propName}`,
    `@${propName}`,
    `v-model:${propName}`
  ];
  for (const name of possibleNames) {
    if (name in attributes) {
      return {
        name,
        value: attributes[name],
        isDynamic: name.startsWith(":") || name.startsWith("v-bind"),
        isVModel: name.startsWith("v-model"),
        isEvent: name.startsWith("@")
      };
    }
  }
  return null;
};
var useComponentOptions = (code2, source, vNode) => {
  const props = computed(() => {
    var _a;
    if (!code2.attributes.value) {
      return {};
    }
    const props2 = {};
    for (const name in code2.meta.value.props) {
      const propMeta = (_a = code2.meta.value.props) == null ? void 0 : _a[name];
      const attributeFromCode = findPropFromAttributes(code2.attributes.value, name);
      props2[name] = {
        name,
        meta: propMeta,
        get currentValue() {
          var _a2, _b;
          return (_b = (_a2 = vNode.value) == null ? void 0 : _a2.props) == null ? void 0 : _b[name];
        },
        get codeValue() {
          return attributeFromCode == null ? void 0 : attributeFromCode.value;
        },
        set codeValue(newCodeValue) {
          source.update(code2.updateAttribute(name, newCodeValue));
        },
        codeAttribute: attributeFromCode ?? void 0,
        updateAttribute: code2.updateAttribute
      };
    }
    return props2;
  });
  const slots = computed(() => {
    var _a;
    return ((_a = code2.slots.value) == null ? void 0 : _a.map((slot) => {
      let timeout;
      return {
        name: slot.name,
        get codeValue() {
          return slot.text;
        },
        set codeValue(newCodeValue) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            source.update(code2.updateSlot(slot.name, newCodeValue));
          }, 300);
        }
      };
    })) ?? [];
  });
  const style = computed({
    get() {
      var _a;
      if (!((_a = code2.attributes.value) == null ? void 0 : _a.style)) {
        return {};
      }
      return code2.attributes.value.style.split(";").reduce((acc, style2) => {
        const [key2, value] = style2.split(":");
        if (key2 && value) {
          acc[key2.trim()] = value.trim();
        }
        return acc;
      }, {});
    },
    set(newStyle) {
      const style2 = Object.entries(newStyle).map(([key2, value]) => `${key2}: ${value}`).join("; ");
      source.update(code2.updateAttribute("style", style2));
    }
  });
  return {
    props,
    slots,
    style
  };
};
var useComponent = defineGlobal(() => {
  const {
    selectedAppTreeItem: selectedAppTreeItem2,
    selectAppTreeItem
  } = useAppTree();
  const vNode = computed(() => {
    var _a;
    return ((_a = selectedAppTreeItem2.value) == null ? void 0 : _a.vnode) ?? null;
  });
  const element2 = computed(() => {
    var _a;
    return ((_a = selectedAppTreeItem2.value) == null ? void 0 : _a.el) ?? null;
  });
  const uid = computed(() => {
    var _a;
    return (_a = selectedAppTreeItem2.value) == null ? void 0 : _a.ids[0];
  });
  const name = computed(() => {
    var _a;
    return (_a = selectedAppTreeItem2.value) == null ? void 0 : _a.name;
  });
  const source = useComponentSource(uid);
  const code2 = useComponentCode(source, vNode);
  const options = useComponentOptions(code2, source, vNode);
  return {
    uid,
    name,
    element: element2,
    source,
    code: code2,
    options,
    setComponent: selectAppTreeItem
  };
});
var useApp = () => {
  const app = document.querySelector("#app");
  if (!app) {
    throw new Error("VuesticDevtools: App element not found when accessing Vuestic Config");
  }
  const vueApp = ref();
  const tryGetVueApp = () => {
    vueApp.value = app.__vue_app__;
    if (!vueApp.value) {
      requestAnimationFrame(tryGetVueApp);
    }
  };
  tryGetVueApp();
  return vueApp;
};
var useAppVuesticConfig = () => {
  const vueApp = useApp();
  return computed(() => {
    var _a;
    return (_a = vueApp.value) == null ? void 0 : _a.config.globalProperties.$vaConfig.globalConfig;
  });
};
var _hoisted_1$h = { class: "color-option__option" };
var _sfc_main$s = defineComponent({
  __name: "Color",
  props: mergeModels({
    label: {},
    prop: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const config = useAppVuesticConfig();
    const colorOptions = computed(() => {
      var _a, _b;
      const variables = (_b = (_a = config.value) == null ? void 0 : _a.colors) == null ? void 0 : _b.variables;
      if (!variables) return [];
      return [...Object.keys(variables)];
    });
    const toCamelCase = (str) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
    const getColor = (name) => {
      var _a;
      return (_a = config.value) == null ? void 0 : _a.colors.variables[toCamelCase(name)];
    };
    const props = __props;
    const vModel = useModel(__props, "modelValue");
    const vModelProxy = computed({
      get() {
        return toCamelCase(vModel.value ?? props.prop.meta.default ?? "");
      },
      set(v) {
        if (v === "") {
          vModel.value = void 0;
        } else {
          vModel.value = v;
        }
      }
    });
    return (_ctx, _cache) => {
      return unref(config) ? (openBlock(), createBlock(unref(VaSelect), {
        key: 0,
        options: colorOptions.value,
        class: "color-option",
        label: props.label,
        modelValue: vModelProxy.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vModelProxy.value = $event),
        clearable: vModelProxy.value !== _ctx.prop.meta.default
      }, {
        "option-content": withCtx(({ option: option2 }) => [
          createBaseVNode("div", _hoisted_1$h, [
            option2 && option2 !== "unset" ? (openBlock(), createBlock(unref(VaColorIndicator), {
              key: 0,
              color: getColor(option2),
              class: "color-option__color"
            }, null, 8, ["color"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(option2), 1)
          ])
        ]),
        _: 1
      }, 8, ["options", "label", "modelValue", "clearable"])) : createCommentVNode("", true);
    };
  }
});
var Color = _export_sfc(_sfc_main$s, [["__scopeId", "data-v-32b4dcc4"]]);
var _sfc_main$r = defineComponent({
  __name: "MultiText",
  props: mergeModels({
    label: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const vModel = useModel(__props, "modelValue");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInput), {
        label: props.label,
        modelValue: vModel.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vModel.value = $event)
      }, null, 8, ["label", "modelValue"]);
    };
  }
});
var _hoisted_1$g = { class: "checkbox-option" };
var _hoisted_2$9 = { class: "va-label" };
var _hoisted_3$9 = { class: "checkbox-option__box" };
var _sfc_main$q = defineComponent({
  __name: "Checkbox",
  props: mergeModels({
    label: {},
    prop: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const vModel = useModel(__props, "modelValue");
    const vModelProxy = computed({
      get() {
        return vModel.value === "true" || vModel.value === null;
      },
      set(v) {
        var _a;
        const prop = props.prop;
        prop.updateAttribute(((_a = prop.codeAttribute) == null ? void 0 : _a.name) ?? prop.name, void 0);
        if (v === prop.meta.default) {
          return;
        }
        if (v === true) {
          prop.updateAttribute(prop.name, null);
        } else {
          prop.updateAttribute(prop.name, "false", "bind");
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$9, toDisplayString(props.label), 1),
        createBaseVNode("div", _hoisted_3$9, [
          createVNode(unref(VaCheckbox), {
            label: vModelProxy.value ? "true" : "false",
            modelValue: vModelProxy.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vModelProxy.value = $event)
          }, null, 8, ["label", "modelValue"])
        ])
      ]);
    };
  }
});
var globalConfig = {
  color: { type: "color" },
  textColor: { type: "color" },
  background: { type: "color" },
  backgroundColor: { type: "color" },
  stripeColor: { type: "color" },
  to: { type: "text" },
  preset: { type: "multi-text" },
  sizesConfig: { type: "disabled" },
  fontSizesConfig: { type: "disabled" }
};
var componentsConfig = {};
var getPropConfig = (component, prop) => {
  if (componentsConfig[component] && componentsConfig[component][prop]) {
    return componentsConfig[component][prop];
  }
  return globalConfig[prop];
};
var _hoisted_1$f = { class: "number-option" };
var _sfc_main$p = defineComponent({
  __name: "Number",
  props: mergeModels({
    label: {},
    prop: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const vModel = useModel(__props, "modelValue");
    const clearValue = () => {
      var _a;
      props.prop.updateAttribute(((_a = props.prop.codeAttribute) == null ? void 0 : _a.name) ?? props.prop.name, void 0);
    };
    const vModelProxy = computed({
      get() {
        return vModel.value ?? props.prop.meta.default;
      },
      set(v) {
        var _a;
        const prop = props.prop;
        prop.updateAttribute(((_a = prop.codeAttribute) == null ? void 0 : _a.name) ?? prop.name, void 0);
        if (v === prop.meta.default) {
          return;
        }
        prop.updateAttribute(prop.name, v.toString(), "bind");
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createVNode(unref(VaCounter), {
          class: "number-option__input",
          label: props.label,
          modelValue: vModelProxy.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vModelProxy.value = $event),
          "manual-input": ""
        }, null, 8, ["label", "modelValue"]),
        createVNode(unref(VaButton), {
          class: "number-option__reset-button",
          onClick: clearValue,
          icon: "va-clear",
          preset: "secondary",
          disabled: vModelProxy.value === _ctx.prop.meta.default
        }, null, 8, ["disabled"])
      ]);
    };
  }
});
var NumberInput = _export_sfc(_sfc_main$p, [["__scopeId", "data-v-f94fa3ea"]]);
var _hoisted_1$e = { class: "not-avaliable-option" };
var _hoisted_2$8 = { class: "va-label" };
var _hoisted_3$8 = createBaseVNode("div", { class: "not-avaliable-option__box" }, " Not avaliable ", -1);
var _sfc_main$o = defineComponent({
  __name: "NotAvaliable",
  props: {
    label: {}
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        createBaseVNode("div", _hoisted_2$8, toDisplayString(props.label), 1),
        _hoisted_3$8
      ]);
    };
  }
});
var _hoisted_1$d = { class: "component-props" };
var _hoisted_2$7 = { key: 7 };
var _hoisted_3$7 = { class: "va-label" };
var _hoisted_4$3 = createBaseVNode("div", { style: { "height": "36px", "line-height": "36px" } }, " This prop can be edited only in Source Code tab for now. ", -1);
var _sfc_main$n = defineComponent({
  __name: "ComponentProps",
  setup(__props) {
    const { options, name } = useComponent();
    const getTypeFromProp = (proptype) => {
      if (proptype === void 0) {
        return "text";
      }
      if (proptype === String) {
        return "text";
      }
      if (proptype === Number) {
        return "number";
      }
      if (proptype === Boolean) {
        return "checkbox";
      }
      if (Array.isArray(proptype)) {
        proptype = proptype.filter((t) => t !== null);
        if (proptype.length === 2) {
          if (proptype.includes(String) && proptype.includes(Number)) {
            return "text";
          }
        }
      }
      return "unknown";
    };
    const propsFilter = ref("");
    const propsConfigs = computed(() => {
      return Object.entries(options.props.value).map(([propName, p2]) => {
        const prop = p2;
        const customConfig = getPropConfig(name.value ?? "", propName);
        const type = (customConfig == null ? void 0 : customConfig.type) ?? getTypeFromProp(prop.meta.type);
        if (type === "unknown") {
          console.error(`Unknown type for prop ${propName}`, prop.meta.type);
        }
        return {
          ...customConfig,
          name: propName,
          prop,
          type,
          get value() {
            return prop.codeValue;
          },
          set value(value) {
            prop.codeValue = value;
          }
        };
      }).sort((a, b) => a.name.localeCompare(b.name)).filter((prop) => prop.name.toLowerCase().includes(propsFilter.value.toLowerCase()));
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        createVNode(unref(VaInput), {
          modelValue: propsFilter.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => propsFilter.value = $event),
          class: "component-settings__search-field",
          placeholder: "Search"
        }, {
          prependInner: withCtx(() => [
            createVNode(unref(VaIcon), { name: "search" })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createVNode(unref(VaDivider)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(propsConfigs.value, (prop) => {
          return openBlock(), createElementBlock(Fragment, null, [
            prop.type === "color" ? (openBlock(), createBlock(Color, {
              key: 0,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event,
              prop: prop.prop
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue", "prop"])) : prop.type === "text" ? (openBlock(), createBlock(unref(VaInput), {
              key: 1,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : prop.type === "checkbox" ? (openBlock(), createBlock(_sfc_main$q, {
              key: 2,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event,
              prop: prop.prop
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue", "prop"])) : prop.type === "select" ? (openBlock(), createBlock(unref(VaSelect), {
              key: 3,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event,
              options: "options" in prop ? prop.options : []
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue", "options"])) : prop.type === "number" ? (openBlock(), createBlock(NumberInput, {
              key: 4,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event,
              prop: prop.prop
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue", "prop"])) : prop.type === "multi-text" ? (openBlock(), createBlock(_sfc_main$r, {
              key: 5,
              label: prop.name,
              modelValue: prop.value,
              "onUpdate:modelValue": ($event) => prop.value = $event
            }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : prop.type === "disabled" ? (openBlock(), createBlock(_sfc_main$o, {
              key: 6,
              label: prop.name
            }, null, 8, ["label"])) : (openBlock(), createElementBlock("div", _hoisted_2$7, [
              createBaseVNode("div", _hoisted_3$7, toDisplayString(prop.name), 1),
              _hoisted_4$3
            ]))
          ], 64);
        }), 256))
      ]);
    };
  }
});
var _hoisted_1$c = { class: "component-slots" };
var _sfc_main$m = defineComponent({
  __name: "ComponentSlots",
  setup(__props) {
    const { options: { slots } } = useComponent();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(slots), (slot) => {
          return openBlock(), createBlock(unref(VaTextarea), {
            modelValue: slot.codeValue,
            "onUpdate:modelValue": ($event) => slot.codeValue = $event,
            label: slot.name
          }, null, 8, ["modelValue", "onUpdate:modelValue", "label"]);
        }), 256))
      ]);
    };
  }
});
var ComponentSlots = _export_sfc(_sfc_main$m, [["__scopeId", "data-v-406ffc41"]]);
var getWasmInlined = async (info) => {
  return import("./wasm-I4DCRSZO.js").then((wasm) => wasm.default(info));
};
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
  FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
  FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
})(FontStyle || (FontStyle = {}));
({
  InDebugMode: typeof process !== "undefined" && !!process.env["VSCODE_TEXTMATE_DEBUG"]
});
var EncodedTokenAttributes;
(function(EncodedTokenAttributes2) {
  function toBinaryStr(encodedTokenAttributes) {
    return encodedTokenAttributes.toString(2).padStart(32, "0");
  }
  EncodedTokenAttributes2.toBinaryStr = toBinaryStr;
  function print(encodedTokenAttributes) {
    const languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);
    const tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);
    const fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);
    const foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);
    const background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);
    console.log({
      languageId,
      tokenType,
      fontStyle,
      foreground,
      background
    });
  }
  EncodedTokenAttributes2.print = print;
  function getLanguageId(encodedTokenAttributes) {
    return (encodedTokenAttributes & 255) >>> 0;
  }
  EncodedTokenAttributes2.getLanguageId = getLanguageId;
  function getTokenType(encodedTokenAttributes) {
    return (encodedTokenAttributes & 768) >>> 8;
  }
  EncodedTokenAttributes2.getTokenType = getTokenType;
  function containsBalancedBrackets(encodedTokenAttributes) {
    return (encodedTokenAttributes & 1024) !== 0;
  }
  EncodedTokenAttributes2.containsBalancedBrackets = containsBalancedBrackets;
  function getFontStyle(encodedTokenAttributes) {
    return (encodedTokenAttributes & 30720) >>> 11;
  }
  EncodedTokenAttributes2.getFontStyle = getFontStyle;
  function getForeground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 16744448) >>> 15;
  }
  EncodedTokenAttributes2.getForeground = getForeground;
  function getBackground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 4278190080) >>> 24;
  }
  EncodedTokenAttributes2.getBackground = getBackground;
  function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets2, fontStyle, foreground, background) {
    let _languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);
    let _tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);
    let _containsBalancedBracketsBit = EncodedTokenAttributes2.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;
    let _fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);
    let _foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);
    let _background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);
    if (languageId !== 0) {
      _languageId = languageId;
    }
    if (tokenType !== 8) {
      _tokenType = fromOptionalTokenType(tokenType);
    }
    if (containsBalancedBrackets2 !== null) {
      _containsBalancedBracketsBit = containsBalancedBrackets2 ? 1 : 0;
    }
    if (fontStyle !== -1) {
      _fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      _foreground = foreground;
    }
    if (background !== 0) {
      _background = background;
    }
    return (_languageId << 0 | _tokenType << 8 | _containsBalancedBracketsBit << 10 | _fontStyle << 11 | _foreground << 15 | _background << 24) >>> 0;
  }
  EncodedTokenAttributes2.set = set;
})(EncodedTokenAttributes || (EncodedTokenAttributes = {}));
function toOptionalTokenType(standardType) {
  return standardType;
}
function fromOptionalTokenType(standardType) {
  return standardType;
}
function createMatchers(selector, matchesName) {
  const results = [];
  const tokenizer = newTokenizer(selector);
  let token = tokenizer.next();
  while (token !== null) {
    let priority = 0;
    if (token.length === 2 && token.charAt(1) === ":") {
      switch (token.charAt(0)) {
        case "R":
          priority = 1;
          break;
        case "L":
          priority = -1;
          break;
        default:
          console.log(`Unknown priority ${token} in scope selector`);
      }
      token = tokenizer.next();
    }
    let matcher = parseConjunction();
    results.push({ matcher, priority });
    if (token !== ",") {
      break;
    }
    token = tokenizer.next();
  }
  return results;
  function parseOperand() {
    if (token === "-") {
      token = tokenizer.next();
      const expressionToNegate = parseOperand();
      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);
    }
    if (token === "(") {
      token = tokenizer.next();
      const expressionInParents = parseInnerExpression();
      if (token === ")") {
        token = tokenizer.next();
      }
      return expressionInParents;
    }
    if (isIdentifier(token)) {
      const identifiers = [];
      do {
        identifiers.push(token);
        token = tokenizer.next();
      } while (isIdentifier(token));
      return (matcherInput) => matchesName(identifiers, matcherInput);
    }
    return null;
  }
  function parseConjunction() {
    const matchers = [];
    let matcher = parseOperand();
    while (matcher) {
      matchers.push(matcher);
      matcher = parseOperand();
    }
    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));
  }
  function parseInnerExpression() {
    const matchers = [];
    let matcher = parseConjunction();
    while (matcher) {
      matchers.push(matcher);
      if (token === "|" || token === ",") {
        do {
          token = tokenizer.next();
        } while (token === "|" || token === ",");
      } else {
        break;
      }
      matcher = parseConjunction();
    }
    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));
  }
}
function isIdentifier(token) {
  return !!token && !!token.match(/[\w\.:]+/);
}
function newTokenizer(input) {
  let regex = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g;
  let match = regex.exec(input);
  return {
    next: () => {
      if (!match) {
        return null;
      }
      const res = match[0];
      match = regex.exec(input);
      return res;
    }
  };
}
function disposeOnigString(str) {
  if (typeof str.dispose === "function") {
    str.dispose();
  }
}
function clone(something) {
  return doClone(something);
}
function doClone(something) {
  if (Array.isArray(something)) {
    return cloneArray(something);
  }
  if (typeof something === "object") {
    return cloneObj(something);
  }
  return something;
}
function cloneArray(arr) {
  let r = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    r[i] = doClone(arr[i]);
  }
  return r;
}
function cloneObj(obj) {
  let r = {};
  for (let key2 in obj) {
    r[key2] = doClone(obj[key2]);
  }
  return r;
}
function mergeObjects(target, ...sources) {
  sources.forEach((source) => {
    for (let key2 in source) {
      target[key2] = source[key2];
    }
  });
  return target;
}
function basename(path) {
  const idx = ~path.lastIndexOf("/") || ~path.lastIndexOf("\\");
  if (idx === 0) {
    return path;
  } else if (~idx === path.length - 1) {
    return basename(path.substring(0, path.length - 1));
  } else {
    return path.substr(~idx + 1);
  }
}
var CAPTURING_REGEX_SOURCE = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
var RegexSource = class {
  static hasCaptures(regexSource) {
    if (regexSource === null) {
      return false;
    }
    CAPTURING_REGEX_SOURCE.lastIndex = 0;
    return CAPTURING_REGEX_SOURCE.test(regexSource);
  }
  static replaceCaptures(regexSource, captureSource, captureIndices) {
    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {
      let capture = captureIndices[parseInt(index || commandIndex, 10)];
      if (capture) {
        let result = captureSource.substring(capture.start, capture.end);
        while (result[0] === ".") {
          result = result.substring(1);
        }
        switch (command) {
          case "downcase":
            return result.toLowerCase();
          case "upcase":
            return result.toUpperCase();
          default:
            return result;
        }
      } else {
        return match;
      }
    });
  }
};
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function strArrCmp(a, b) {
  if (a === null && b === null) {
    return 0;
  }
  if (!a) {
    return -1;
  }
  if (!b) {
    return 1;
  }
  let len1 = a.length;
  let len2 = b.length;
  if (len1 === len2) {
    for (let i = 0; i < len1; i++) {
      let res = strcmp(a[i], b[i]);
      if (res !== 0) {
        return res;
      }
    }
    return 0;
  }
  return len1 - len2;
}
function isValidHexColor(hex) {
  if (/^#[0-9a-f]{6}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{8}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{3}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{4}$/i.test(hex)) {
    return true;
  }
  return false;
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var CachedFn = class {
  constructor(fn) {
    __publicField(this, "fn");
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    this.fn = fn;
  }
  get(key2) {
    if (this.cache.has(key2)) {
      return this.cache.get(key2);
    }
    const value = this.fn(key2);
    this.cache.set(key2, value);
    return value;
  }
};
var TopLevelRuleReference = class {
  constructor(scopeName) {
    __publicField(this, "scopeName");
    this.scopeName = scopeName;
  }
  toKey() {
    return this.scopeName;
  }
};
var TopLevelRepositoryRuleReference = class {
  constructor(scopeName, ruleName) {
    __publicField(this, "scopeName");
    __publicField(this, "ruleName");
    this.scopeName = scopeName;
    this.ruleName = ruleName;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
};
var ExternalReferenceCollector = class {
  constructor() {
    __publicField(this, "_references", []);
    __publicField(this, "_seenReferenceKeys", /* @__PURE__ */ new Set());
    __publicField(this, "visitedRule", /* @__PURE__ */ new Set());
  }
  get references() {
    return this._references;
  }
  add(reference) {
    const key2 = reference.toKey();
    if (this._seenReferenceKeys.has(key2)) {
      return;
    }
    this._seenReferenceKeys.add(key2);
    this._references.push(reference);
  }
};
var ScopeDependencyProcessor = class {
  constructor(repo, initialScopeName) {
    __publicField(this, "repo");
    __publicField(this, "initialScopeName");
    __publicField(this, "seenFullScopeRequests", /* @__PURE__ */ new Set());
    __publicField(this, "seenPartialScopeRequests", /* @__PURE__ */ new Set());
    __publicField(this, "Q");
    this.repo = repo;
    this.initialScopeName = initialScopeName;
    this.seenFullScopeRequests.add(this.initialScopeName);
    this.Q = [new TopLevelRuleReference(this.initialScopeName)];
  }
  processQueue() {
    const q = this.Q;
    this.Q = [];
    const deps = new ExternalReferenceCollector();
    for (const dep of q) {
      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);
    }
    for (const dep of deps.references) {
      if (dep instanceof TopLevelRuleReference) {
        if (this.seenFullScopeRequests.has(dep.scopeName)) {
          continue;
        }
        this.seenFullScopeRequests.add(dep.scopeName);
        this.Q.push(dep);
      } else {
        if (this.seenFullScopeRequests.has(dep.scopeName)) {
          continue;
        }
        if (this.seenPartialScopeRequests.has(dep.toKey())) {
          continue;
        }
        this.seenPartialScopeRequests.add(dep.toKey());
        this.Q.push(dep);
      }
    }
  }
};
function collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {
  const selfGrammar = repo.lookup(reference.scopeName);
  if (!selfGrammar) {
    if (reference.scopeName === baseGrammarScopeName) {
      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);
    }
    return;
  }
  const baseGrammar = repo.lookup(baseGrammarScopeName);
  if (reference instanceof TopLevelRuleReference) {
    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);
  } else {
    collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { baseGrammar, selfGrammar, repository: selfGrammar.repository }, result);
  }
  const injections = repo.injections(reference.scopeName);
  if (injections) {
    for (const injection of injections) {
      result.add(new TopLevelRuleReference(injection));
    }
  }
}
function collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {
  if (context.repository && context.repository[ruleName]) {
    const rule = context.repository[ruleName];
    collectExternalReferencesInRules([rule], context, result);
  }
}
function collectExternalReferencesInTopLevelRule(context, result) {
  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {
    collectExternalReferencesInRules(context.selfGrammar.patterns, { ...context, repository: context.selfGrammar.repository }, result);
  }
  if (context.selfGrammar.injections) {
    collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), { ...context, repository: context.selfGrammar.repository }, result);
  }
}
function collectExternalReferencesInRules(rules, context, result) {
  for (const rule of rules) {
    if (result.visitedRule.has(rule)) {
      continue;
    }
    result.visitedRule.add(rule);
    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;
    if (Array.isArray(rule.patterns)) {
      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);
    }
    const include = rule.include;
    if (!include) {
      continue;
    }
    const reference = parseInclude(include);
    switch (reference.kind) {
      case 0:
        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);
        break;
      case 1:
        collectExternalReferencesInTopLevelRule(context, result);
        break;
      case 2:
        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);
        break;
      case 3:
      case 4:
        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;
        if (selfGrammar) {
          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };
          if (reference.kind === 4) {
            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);
          } else {
            collectExternalReferencesInTopLevelRule(newContext, result);
          }
        } else {
          if (reference.kind === 4) {
            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));
          } else {
            result.add(new TopLevelRuleReference(reference.scopeName));
          }
        }
        break;
    }
  }
}
var BaseReference = class {
  constructor() {
    __publicField(this, "kind", 0);
  }
};
var SelfReference = class {
  constructor() {
    __publicField(this, "kind", 1);
  }
};
var RelativeReference = class {
  constructor(ruleName) {
    __publicField(this, "ruleName");
    __publicField(this, "kind", 2);
    this.ruleName = ruleName;
  }
};
var TopLevelReference = class {
  constructor(scopeName) {
    __publicField(this, "scopeName");
    __publicField(this, "kind", 3);
    this.scopeName = scopeName;
  }
};
var TopLevelRepositoryReference = class {
  constructor(scopeName, ruleName) {
    __publicField(this, "scopeName");
    __publicField(this, "ruleName");
    __publicField(this, "kind", 4);
    this.scopeName = scopeName;
    this.ruleName = ruleName;
  }
};
function parseInclude(include) {
  if (include === "$base") {
    return new BaseReference();
  } else if (include === "$self") {
    return new SelfReference();
  }
  const indexOfSharp = include.indexOf("#");
  if (indexOfSharp === -1) {
    return new TopLevelReference(include);
  } else if (indexOfSharp === 0) {
    return new RelativeReference(include.substring(1));
  } else {
    const scopeName = include.substring(0, indexOfSharp);
    const ruleName = include.substring(indexOfSharp + 1);
    return new TopLevelRepositoryReference(scopeName, ruleName);
  }
}
var HAS_BACK_REFERENCES = /\\(\d+)/;
var BACK_REFERENCING_END = /\\(\d+)/g;
var endRuleId = -1;
var whileRuleId = -2;
function ruleIdFromNumber(id) {
  return id;
}
function ruleIdToNumber(id) {
  return id;
}
var Rule = class {
  constructor($location, id, name, contentName) {
    __publicField(this, "$location");
    __publicField(this, "id");
    __publicField(this, "_nameIsCapturing");
    __publicField(this, "_name");
    __publicField(this, "_contentNameIsCapturing");
    __publicField(this, "_contentName");
    this.$location = $location;
    this.id = id;
    this._name = name || null;
    this._nameIsCapturing = RegexSource.hasCaptures(this._name);
    this._contentName = contentName || null;
    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);
  }
  get debugName() {
    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${location}`;
  }
  getName(lineText, captureIndices) {
    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {
      return this._name;
    }
    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);
  }
  getContentName(lineText, captureIndices) {
    if (!this._contentNameIsCapturing || this._contentName === null) {
      return this._contentName;
    }
    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);
  }
};
var CaptureRule = class extends Rule {
  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {
    super($location, id, name, contentName);
    __publicField(this, "retokenizeCapturedWithRuleId");
    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;
  }
  dispose() {
  }
  collectPatterns(grammar, out) {
    throw new Error("Not supported!");
  }
  compile(grammar, endRegexSource) {
    throw new Error("Not supported!");
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    throw new Error("Not supported!");
  }
};
var MatchRule = class extends Rule {
  constructor($location, id, name, match, captures) {
    super($location, id, name, null);
    __publicField(this, "_match");
    __publicField(this, "captures");
    __publicField(this, "_cachedCompiledPatterns");
    this._match = new RegExpSource(match, this.id);
    this.captures = captures;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(grammar, out) {
    out.push(this._match);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      this.collectPatterns(grammar, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
};
var IncludeOnlyRule = class extends Rule {
  constructor($location, id, name, contentName, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  collectPatterns(grammar, out) {
    for (const pattern of this.patterns) {
      const rule = grammar.getRule(pattern);
      rule.collectPatterns(grammar, out);
    }
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      this.collectPatterns(grammar, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
};
var BeginEndRule = class extends Rule {
  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "_begin");
    __publicField(this, "beginCaptures");
    __publicField(this, "_end");
    __publicField(this, "endHasBackReferences");
    __publicField(this, "endCaptures");
    __publicField(this, "applyEndPatternLast");
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    this._begin = new RegExpSource(begin, this.id);
    this.beginCaptures = beginCaptures;
    this._end = new RegExpSource(end ? end : "￿", -1);
    this.endHasBackReferences = this._end.hasBackReferences;
    this.endCaptures = endCaptures;
    this.applyEndPatternLast = applyEndPatternLast || false;
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(lineText, captureIndices) {
    return this._end.resolveBackReferences(lineText, captureIndices);
  }
  collectPatterns(grammar, out) {
    out.push(this._begin);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar, endRegexSource) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      for (const pattern of this.patterns) {
        const rule = grammar.getRule(pattern);
        rule.collectPatterns(grammar, this._cachedCompiledPatterns);
      }
      if (this.applyEndPatternLast) {
        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);
      } else {
        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
      }
    }
    if (this._end.hasBackReferences) {
      if (this.applyEndPatternLast) {
        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);
      } else {
        this._cachedCompiledPatterns.setSource(0, endRegexSource);
      }
    }
    return this._cachedCompiledPatterns;
  }
};
var BeginWhileRule = class extends Rule {
  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "_begin");
    __publicField(this, "beginCaptures");
    __publicField(this, "whileCaptures");
    __publicField(this, "_while");
    __publicField(this, "whileHasBackReferences");
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    __publicField(this, "_cachedCompiledWhilePatterns");
    this._begin = new RegExpSource(begin, this.id);
    this.beginCaptures = beginCaptures;
    this.whileCaptures = whileCaptures;
    this._while = new RegExpSource(_while, whileRuleId);
    this.whileHasBackReferences = this._while.hasBackReferences;
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
    this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
    if (this._cachedCompiledWhilePatterns) {
      this._cachedCompiledWhilePatterns.dispose();
      this._cachedCompiledWhilePatterns = null;
    }
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(lineText, captureIndices) {
    return this._while.resolveBackReferences(lineText, captureIndices);
  }
  collectPatterns(grammar, out) {
    out.push(this._begin);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      for (const pattern of this.patterns) {
        const rule = grammar.getRule(pattern);
        rule.collectPatterns(grammar, this._cachedCompiledPatterns);
      }
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(grammar, endRegexSource) {
    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);
  }
  compileWhileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {
    if (!this._cachedCompiledWhilePatterns) {
      this._cachedCompiledWhilePatterns = new RegExpSourceList();
      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);
    }
    if (this._while.hasBackReferences) {
      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : "￿");
    }
    return this._cachedCompiledWhilePatterns;
  }
};
var RuleFactory = class _RuleFactory {
  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {
    return helper.registerRule((id) => {
      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);
    });
  }
  static getCompiledRuleId(desc, helper, repository) {
    if (!desc.id) {
      helper.registerRule((id) => {
        desc.id = id;
        if (desc.match) {
          return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, _RuleFactory._compileCaptures(desc.captures, helper, repository));
        }
        if (typeof desc.begin === "undefined") {
          if (desc.repository) {
            repository = mergeObjects({}, repository, desc.repository);
          }
          let patterns = desc.patterns;
          if (typeof patterns === "undefined" && desc.include) {
            patterns = [{ include: desc.include }];
          }
          return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, _RuleFactory._compilePatterns(patterns, helper, repository));
        }
        if (desc.while) {
          return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), _RuleFactory._compilePatterns(desc.patterns, helper, repository));
        }
        return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, _RuleFactory._compilePatterns(desc.patterns, helper, repository));
      });
    }
    return desc.id;
  }
  static _compileCaptures(captures, helper, repository) {
    let r = [];
    if (captures) {
      let maximumCaptureId = 0;
      for (const captureId in captures) {
        if (captureId === "$vscodeTextmateLocation") {
          continue;
        }
        const numericCaptureId = parseInt(captureId, 10);
        if (numericCaptureId > maximumCaptureId) {
          maximumCaptureId = numericCaptureId;
        }
      }
      for (let i = 0; i <= maximumCaptureId; i++) {
        r[i] = null;
      }
      for (const captureId in captures) {
        if (captureId === "$vscodeTextmateLocation") {
          continue;
        }
        const numericCaptureId = parseInt(captureId, 10);
        let retokenizeCapturedWithRuleId = 0;
        if (captures[captureId].patterns) {
          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);
        }
        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);
      }
    }
    return r;
  }
  static _compilePatterns(patterns, helper, repository) {
    let r = [];
    if (patterns) {
      for (let i = 0, len = patterns.length; i < len; i++) {
        const pattern = patterns[i];
        let ruleId = -1;
        if (pattern.include) {
          const reference = parseInclude(pattern.include);
          switch (reference.kind) {
            case 0:
            case 1:
              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);
              break;
            case 2:
              let localIncludedRule = repository[reference.ruleName];
              if (localIncludedRule) {
                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);
              }
              break;
            case 3:
            case 4:
              const externalGrammarName = reference.scopeName;
              const externalGrammarInclude = reference.kind === 4 ? reference.ruleName : null;
              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);
              if (externalGrammar) {
                if (externalGrammarInclude) {
                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];
                  if (externalIncludedRule) {
                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);
                  }
                } else {
                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);
                }
              }
              break;
          }
        } else {
          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);
        }
        if (ruleId !== -1) {
          const rule = helper.getRule(ruleId);
          let skipRule = false;
          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {
            if (rule.hasMissingPatterns && rule.patterns.length === 0) {
              skipRule = true;
            }
          }
          if (skipRule) {
            continue;
          }
          r.push(ruleId);
        }
      }
    }
    return {
      patterns: r,
      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length
    };
  }
};
var RegExpSource = class _RegExpSource {
  constructor(regExpSource, ruleId) {
    __publicField(this, "source");
    __publicField(this, "ruleId");
    __publicField(this, "hasAnchor");
    __publicField(this, "hasBackReferences");
    __publicField(this, "_anchorCache");
    if (regExpSource) {
      const len = regExpSource.length;
      let lastPushedPos = 0;
      let output = [];
      let hasAnchor = false;
      for (let pos = 0; pos < len; pos++) {
        const ch = regExpSource.charAt(pos);
        if (ch === "\\") {
          if (pos + 1 < len) {
            const nextCh = regExpSource.charAt(pos + 1);
            if (nextCh === "z") {
              output.push(regExpSource.substring(lastPushedPos, pos));
              output.push("$(?!\\n)(?<!\\n)");
              lastPushedPos = pos + 2;
            } else if (nextCh === "A" || nextCh === "G") {
              hasAnchor = true;
            }
            pos++;
          }
        }
      }
      this.hasAnchor = hasAnchor;
      if (lastPushedPos === 0) {
        this.source = regExpSource;
      } else {
        output.push(regExpSource.substring(lastPushedPos, len));
        this.source = output.join("");
      }
    } else {
      this.hasAnchor = false;
      this.source = regExpSource;
    }
    if (this.hasAnchor) {
      this._anchorCache = this._buildAnchorCache();
    } else {
      this._anchorCache = null;
    }
    this.ruleId = ruleId;
    this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);
  }
  clone() {
    return new _RegExpSource(this.source, this.ruleId);
  }
  setSource(newSource) {
    if (this.source === newSource) {
      return;
    }
    this.source = newSource;
    if (this.hasAnchor) {
      this._anchorCache = this._buildAnchorCache();
    }
  }
  resolveBackReferences(lineText, captureIndices) {
    let capturedValues = captureIndices.map((capture) => {
      return lineText.substring(capture.start, capture.end);
    });
    BACK_REFERENCING_END.lastIndex = 0;
    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {
      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || "");
    });
  }
  _buildAnchorCache() {
    let A0_G0_result = [];
    let A0_G1_result = [];
    let A1_G0_result = [];
    let A1_G1_result = [];
    let pos, len, ch, nextCh;
    for (pos = 0, len = this.source.length; pos < len; pos++) {
      ch = this.source.charAt(pos);
      A0_G0_result[pos] = ch;
      A0_G1_result[pos] = ch;
      A1_G0_result[pos] = ch;
      A1_G1_result[pos] = ch;
      if (ch === "\\") {
        if (pos + 1 < len) {
          nextCh = this.source.charAt(pos + 1);
          if (nextCh === "A") {
            A0_G0_result[pos + 1] = "￿";
            A0_G1_result[pos + 1] = "￿";
            A1_G0_result[pos + 1] = "A";
            A1_G1_result[pos + 1] = "A";
          } else if (nextCh === "G") {
            A0_G0_result[pos + 1] = "￿";
            A0_G1_result[pos + 1] = "G";
            A1_G0_result[pos + 1] = "￿";
            A1_G1_result[pos + 1] = "G";
          } else {
            A0_G0_result[pos + 1] = nextCh;
            A0_G1_result[pos + 1] = nextCh;
            A1_G0_result[pos + 1] = nextCh;
            A1_G1_result[pos + 1] = nextCh;
          }
          pos++;
        }
      }
    }
    return {
      A0_G0: A0_G0_result.join(""),
      A0_G1: A0_G1_result.join(""),
      A1_G0: A1_G0_result.join(""),
      A1_G1: A1_G1_result.join("")
    };
  }
  resolveAnchors(allowA, allowG) {
    if (!this.hasAnchor || !this._anchorCache) {
      return this.source;
    }
    if (allowA) {
      if (allowG) {
        return this._anchorCache.A1_G1;
      } else {
        return this._anchorCache.A1_G0;
      }
    } else {
      if (allowG) {
        return this._anchorCache.A0_G1;
      } else {
        return this._anchorCache.A0_G0;
      }
    }
  }
};
var RegExpSourceList = class {
  constructor() {
    __publicField(this, "_items");
    __publicField(this, "_hasAnchors");
    __publicField(this, "_cached");
    __publicField(this, "_anchorCache");
    this._items = [];
    this._hasAnchors = false;
    this._cached = null;
    this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    if (this._cached) {
      this._cached.dispose();
      this._cached = null;
    }
    if (this._anchorCache.A0_G0) {
      this._anchorCache.A0_G0.dispose();
      this._anchorCache.A0_G0 = null;
    }
    if (this._anchorCache.A0_G1) {
      this._anchorCache.A0_G1.dispose();
      this._anchorCache.A0_G1 = null;
    }
    if (this._anchorCache.A1_G0) {
      this._anchorCache.A1_G0.dispose();
      this._anchorCache.A1_G0 = null;
    }
    if (this._anchorCache.A1_G1) {
      this._anchorCache.A1_G1.dispose();
      this._anchorCache.A1_G1 = null;
    }
  }
  push(item) {
    this._items.push(item);
    this._hasAnchors = this._hasAnchors || item.hasAnchor;
  }
  unshift(item) {
    this._items.unshift(item);
    this._hasAnchors = this._hasAnchors || item.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(index, newSource) {
    if (this._items[index].source !== newSource) {
      this._disposeCaches();
      this._items[index].setSource(newSource);
    }
  }
  compile(onigLib) {
    if (!this._cached) {
      let regExps = this._items.map((e) => e.source);
      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));
    }
    return this._cached;
  }
  compileAG(onigLib, allowA, allowG) {
    if (!this._hasAnchors) {
      return this.compile(onigLib);
    } else {
      if (allowA) {
        if (allowG) {
          if (!this._anchorCache.A1_G1) {
            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A1_G1;
        } else {
          if (!this._anchorCache.A1_G0) {
            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A1_G0;
        }
      } else {
        if (allowG) {
          if (!this._anchorCache.A0_G1) {
            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A0_G1;
        } else {
          if (!this._anchorCache.A0_G0) {
            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A0_G0;
        }
      }
    }
  }
  _resolveAnchors(onigLib, allowA, allowG) {
    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));
    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));
  }
};
var CompiledRule = class {
  constructor(onigLib, regExps, rules) {
    __publicField(this, "regExps");
    __publicField(this, "rules");
    __publicField(this, "scanner");
    this.regExps = regExps;
    this.rules = rules;
    this.scanner = onigLib.createOnigScanner(regExps);
  }
  dispose() {
    if (typeof this.scanner.dispose === "function") {
      this.scanner.dispose();
    }
  }
  toString() {
    const r = [];
    for (let i = 0, len = this.rules.length; i < len; i++) {
      r.push("   - " + this.rules[i] + ": " + this.regExps[i]);
    }
    return r.join("\n");
  }
  findNextMatchSync(string, startPosition, options) {
    const result = this.scanner.findNextMatchSync(string, startPosition, options);
    if (!result) {
      return null;
    }
    return {
      ruleId: this.rules[result.index],
      captureIndices: result.captureIndices
    };
  }
};
var Theme = class {
  constructor(_colorMap, _defaults, _root) {
    __publicField(this, "_colorMap");
    __publicField(this, "_defaults");
    __publicField(this, "_root");
    __publicField(this, "_cachedMatchRoot", new CachedFn((scopeName) => this._root.match(scopeName)));
    this._colorMap = _colorMap;
    this._defaults = _defaults;
    this._root = _root;
  }
  static createFromRawTheme(source, colorMap) {
    return this.createFromParsedTheme(parseTheme(source), colorMap);
  }
  static createFromParsedTheme(source, colorMap) {
    return resolveParsedThemeRules(source, colorMap);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(scopePath) {
    if (scopePath === null) {
      return this._defaults;
    }
    const scopeName = scopePath.scopeName;
    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);
    const effectiveRule = matchingTrieElements.find((v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));
    if (!effectiveRule) {
      return null;
    }
    return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);
  }
};
var ScopeStack = class _ScopeStack {
  constructor(parent, scopeName) {
    __publicField(this, "parent");
    __publicField(this, "scopeName");
    this.parent = parent;
    this.scopeName = scopeName;
  }
  static push(path, scopeNames) {
    for (const name of scopeNames) {
      path = new _ScopeStack(path, name);
    }
    return path;
  }
  static from(...segments) {
    let result = null;
    for (let i = 0; i < segments.length; i++) {
      result = new _ScopeStack(result, segments[i]);
    }
    return result;
  }
  push(scopeName) {
    return new _ScopeStack(this, scopeName);
  }
  getSegments() {
    let item = this;
    const result = [];
    while (item) {
      result.push(item.scopeName);
      item = item.parent;
    }
    result.reverse();
    return result;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(other) {
    if (this === other) {
      return true;
    }
    if (this.parent === null) {
      return false;
    }
    return this.parent.extends(other);
  }
  getExtensionIfDefined(base) {
    const result = [];
    let item = this;
    while (item && item !== base) {
      result.push(item.scopeName);
      item = item.parent;
    }
    return item === base ? result.reverse() : void 0;
  }
};
function _scopePathMatchesParentScopes(scopePath, parentScopes) {
  if (parentScopes === null) {
    return true;
  }
  let index = 0;
  let scopePattern = parentScopes[index];
  while (scopePath) {
    if (_matchesScope(scopePath.scopeName, scopePattern)) {
      index++;
      if (index === parentScopes.length) {
        return true;
      }
      scopePattern = parentScopes[index];
    }
    scopePath = scopePath.parent;
  }
  return false;
}
function _matchesScope(scopeName, scopePattern) {
  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === ".";
}
var StyleAttributes = class {
  constructor(fontStyle, foregroundId, backgroundId) {
    __publicField(this, "fontStyle");
    __publicField(this, "foregroundId");
    __publicField(this, "backgroundId");
    this.fontStyle = fontStyle;
    this.foregroundId = foregroundId;
    this.backgroundId = backgroundId;
  }
};
function parseTheme(source) {
  if (!source) {
    return [];
  }
  if (!source.settings || !Array.isArray(source.settings)) {
    return [];
  }
  let settings = source.settings;
  let result = [], resultLen = 0;
  for (let i = 0, len = settings.length; i < len; i++) {
    let entry = settings[i];
    if (!entry.settings) {
      continue;
    }
    let scopes;
    if (typeof entry.scope === "string") {
      let _scope = entry.scope;
      _scope = _scope.replace(/^[,]+/, "");
      _scope = _scope.replace(/[,]+$/, "");
      scopes = _scope.split(",");
    } else if (Array.isArray(entry.scope)) {
      scopes = entry.scope;
    } else {
      scopes = [""];
    }
    let fontStyle = -1;
    if (typeof entry.settings.fontStyle === "string") {
      fontStyle = 0;
      let segments = entry.settings.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        let segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
          case "strikethrough":
            fontStyle = fontStyle | 8;
            break;
        }
      }
    }
    let foreground = null;
    if (typeof entry.settings.foreground === "string" && isValidHexColor(entry.settings.foreground)) {
      foreground = entry.settings.foreground;
    }
    let background = null;
    if (typeof entry.settings.background === "string" && isValidHexColor(entry.settings.background)) {
      background = entry.settings.background;
    }
    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {
      let _scope = scopes[j].trim();
      let segments = _scope.split(" ");
      let scope = segments[segments.length - 1];
      let parentScopes = null;
      if (segments.length > 1) {
        parentScopes = segments.slice(0, segments.length - 1);
        parentScopes.reverse();
      }
      result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);
    }
  }
  return result;
}
var ParsedThemeRule = class {
  constructor(scope, parentScopes, index, fontStyle, foreground, background) {
    __publicField(this, "scope");
    __publicField(this, "parentScopes");
    __publicField(this, "index");
    __publicField(this, "fontStyle");
    __publicField(this, "foreground");
    __publicField(this, "background");
    this.scope = scope;
    this.parentScopes = parentScopes;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
};
function resolveParsedThemeRules(parsedThemeRules, _colorMap) {
  parsedThemeRules.sort((a, b) => {
    let r = strcmp(a.scope, b.scope);
    if (r !== 0) {
      return r;
    }
    r = strArrCmp(a.parentScopes, b.parentScopes);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "#000000";
  let defaultBackground = "#ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === "") {
    let incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  let colorMap = new ColorMap(_colorMap);
  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));
  let root2 = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1, 0, 0), []);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    let rule = parsedThemeRules[i];
    root2.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new Theme(colorMap, defaults, root2);
}
var ColorMap = class {
  constructor(_colorMap) {
    __publicField(this, "_isFrozen");
    __publicField(this, "_lastColorId");
    __publicField(this, "_id2color");
    __publicField(this, "_color2id");
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = /* @__PURE__ */ Object.create(null);
    if (Array.isArray(_colorMap)) {
      this._isFrozen = true;
      for (let i = 0, len = _colorMap.length; i < len; i++) {
        this._color2id[_colorMap[i]] = i;
        this._id2color[i] = _colorMap[i];
      }
    } else {
      this._isFrozen = false;
    }
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    color = color.toUpperCase();
    let value = this._color2id[color];
    if (value) {
      return value;
    }
    if (this._isFrozen) {
      throw new Error(`Missing color in color map - ${color}`);
    }
    value = ++this._lastColorId;
    this._color2id[color] = value;
    this._id2color[value] = color;
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var ThemeTrieElementRule = class _ThemeTrieElementRule {
  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {
    __publicField(this, "scopeDepth");
    __publicField(this, "parentScopes");
    __publicField(this, "fontStyle");
    __publicField(this, "foreground");
    __publicField(this, "background");
    this.scopeDepth = scopeDepth;
    this.parentScopes = parentScopes;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
  clone() {
    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(arr) {
    let r = [];
    for (let i = 0, len = arr.length; i < len; i++) {
      r[i] = arr[i].clone();
    }
    return r;
  }
  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {
    if (this.scopeDepth > scopeDepth) {
      console.log("how did this happen?");
    } else {
      this.scopeDepth = scopeDepth;
    }
    if (fontStyle !== -1) {
      this.fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      this.foreground = foreground;
    }
    if (background !== 0) {
      this.background = background;
    }
  }
};
var ThemeTrieElement = class _ThemeTrieElement {
  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {
    __publicField(this, "_mainRule");
    __publicField(this, "_children");
    __publicField(this, "_rulesWithParentScopes");
    this._mainRule = _mainRule;
    this._children = _children;
    this._rulesWithParentScopes = rulesWithParentScopes;
  }
  static _sortBySpecificity(arr) {
    if (arr.length === 1) {
      return arr;
    }
    arr.sort(this._cmpBySpecificity);
    return arr;
  }
  static _cmpBySpecificity(a, b) {
    if (a.scopeDepth === b.scopeDepth) {
      const aParentScopes = a.parentScopes;
      const bParentScopes = b.parentScopes;
      let aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;
      let bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;
      if (aParentScopesLen === bParentScopesLen) {
        for (let i = 0; i < aParentScopesLen; i++) {
          const aLen = aParentScopes[i].length;
          const bLen = bParentScopes[i].length;
          if (aLen !== bLen) {
            return bLen - aLen;
          }
        }
      }
      return bParentScopesLen - aParentScopesLen;
    }
    return b.scopeDepth - a.scopeDepth;
  }
  match(scope) {
    if (scope === "") {
      return _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
    }
    let dotIndex = scope.indexOf(".");
    let head2;
    let tail;
    if (dotIndex === -1) {
      head2 = scope;
      tail = "";
    } else {
      head2 = scope.substring(0, dotIndex);
      tail = scope.substring(dotIndex + 1);
    }
    if (this._children.hasOwnProperty(head2)) {
      return this._children[head2].match(tail);
    }
    return _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
  }
  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {
    if (scope === "") {
      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);
      return;
    }
    let dotIndex = scope.indexOf(".");
    let head2;
    let tail;
    if (dotIndex === -1) {
      head2 = scope;
      tail = "";
    } else {
      head2 = scope.substring(0, dotIndex);
      tail = scope.substring(dotIndex + 1);
    }
    let child;
    if (this._children.hasOwnProperty(head2)) {
      child = this._children[head2];
    } else {
      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));
      this._children[head2] = child;
    }
    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);
  }
  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {
    if (parentScopes === null) {
      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
      return;
    }
    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {
      let rule = this._rulesWithParentScopes[i];
      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {
        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
        return;
      }
    }
    if (fontStyle === -1) {
      fontStyle = this._mainRule.fontStyle;
    }
    if (foreground === 0) {
      foreground = this._mainRule.foreground;
    }
    if (background === 0) {
      background = this._mainRule.background;
    }
    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));
  }
};
var BasicScopeAttributes = class {
  constructor(languageId, tokenType) {
    __publicField(this, "languageId");
    __publicField(this, "tokenType");
    this.languageId = languageId;
    this.tokenType = tokenType;
  }
};
var _BasicScopeAttributesProvider = class _BasicScopeAttributesProvider2 {
  constructor(initialLanguageId, embeddedLanguages) {
    __publicField(this, "_defaultAttributes");
    __publicField(this, "_embeddedLanguagesMatcher");
    __publicField(this, "_getBasicScopeAttributes", new CachedFn((scopeName) => {
      const languageId = this._scopeToLanguage(scopeName);
      const standardTokenType = this._toStandardTokenType(scopeName);
      return new BasicScopeAttributes(languageId, standardTokenType);
    }));
    this._defaultAttributes = new BasicScopeAttributes(
      initialLanguageId,
      8
      /* OptionalStandardTokenType.NotSet */
    );
    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(scopeName) {
    if (scopeName === null) {
      return _BasicScopeAttributesProvider2._NULL_SCOPE_METADATA;
    }
    return this._getBasicScopeAttributes.get(scopeName);
  }
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(scope) {
    return this._embeddedLanguagesMatcher.match(scope) || 0;
  }
  _toStandardTokenType(scopeName) {
    const m = scopeName.match(_BasicScopeAttributesProvider2.STANDARD_TOKEN_TYPE_REGEXP);
    if (!m) {
      return 8;
    }
    switch (m[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
};
__publicField(_BasicScopeAttributesProvider, "_NULL_SCOPE_METADATA", new BasicScopeAttributes(0, 0));
__publicField(_BasicScopeAttributesProvider, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/);
var BasicScopeAttributesProvider = _BasicScopeAttributesProvider;
var ScopeMatcher = class {
  constructor(values) {
    __publicField(this, "values");
    __publicField(this, "scopesRegExp");
    if (values.length === 0) {
      this.values = null;
      this.scopesRegExp = null;
    } else {
      this.values = new Map(values);
      const escapedScopes = values.map(([scopeName, value]) => escapeRegExpCharacters(scopeName));
      escapedScopes.sort();
      escapedScopes.reverse();
      this.scopesRegExp = new RegExp(`^((${escapedScopes.join(")|(")}))($|\\.)`, "");
    }
  }
  match(scope) {
    if (!this.scopesRegExp) {
      return void 0;
    }
    const m = scope.match(this.scopesRegExp);
    if (!m) {
      return void 0;
    }
    return this.values.get(m[1]);
  }
};
var TokenizeStringResult = class {
  constructor(stack, stoppedEarly) {
    __publicField(this, "stack");
    __publicField(this, "stoppedEarly");
    this.stack = stack;
    this.stoppedEarly = stoppedEarly;
  }
};
function _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {
  const lineLength = lineText.content.length;
  let STOP = false;
  let anchorPosition = -1;
  if (checkWhileConditions) {
    const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);
    stack = whileCheckResult.stack;
    linePos = whileCheckResult.linePos;
    isFirstLine = whileCheckResult.isFirstLine;
    anchorPosition = whileCheckResult.anchorPosition;
  }
  const startTime = Date.now();
  while (!STOP) {
    if (timeLimit !== 0) {
      const elapsedTime = Date.now() - startTime;
      if (elapsedTime > timeLimit) {
        return new TokenizeStringResult(stack, true);
      }
    }
    scanNext();
  }
  return new TokenizeStringResult(stack, false);
  function scanNext() {
    const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
    if (!r) {
      lineTokens.produce(stack, lineLength);
      STOP = true;
      return;
    }
    const captureIndices = r.captureIndices;
    const matchedRuleId = r.matchedRuleId;
    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;
    if (matchedRuleId === endRuleId) {
      const poppedRule = stack.getRule(grammar);
      lineTokens.produce(stack, captureIndices[0].start);
      stack = stack.withContentNameScopesList(stack.nameScopesList);
      handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);
      lineTokens.produce(stack, captureIndices[0].end);
      const popped = stack;
      stack = stack.parent;
      anchorPosition = popped.getAnchorPos();
      if (!hasAdvanced && popped.getEnterPos() === linePos) {
        stack = popped;
        lineTokens.produce(stack, lineLength);
        STOP = true;
        return;
      }
    } else {
      const _rule = grammar.getRule(matchedRuleId);
      lineTokens.produce(stack, captureIndices[0].start);
      const beforePush = stack;
      const scopeName = _rule.getName(lineText.content, captureIndices);
      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
      stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);
      if (_rule instanceof BeginEndRule) {
        const pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        anchorPosition = captureIndices[0].end;
        const contentName = pushedRule.getContentName(lineText.content, captureIndices);
        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        stack = stack.withContentNameScopesList(contentNameScopesList);
        if (pushedRule.endHasBackReferences) {
          stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));
        }
        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      } else if (_rule instanceof BeginWhileRule) {
        const pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        anchorPosition = captureIndices[0].end;
        const contentName = pushedRule.getContentName(lineText.content, captureIndices);
        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        stack = stack.withContentNameScopesList(contentNameScopesList);
        if (pushedRule.whileHasBackReferences) {
          stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));
        }
        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      } else {
        const matchingRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        stack = stack.pop();
        if (!hasAdvanced) {
          stack = stack.safePop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      }
    }
    if (captureIndices[0].end > linePos) {
      linePos = captureIndices[0].end;
      isFirstLine = false;
    }
  }
}
function _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {
  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;
  const whileRules = [];
  for (let node = stack; node; node = node.pop()) {
    const nodeRule = node.getRule(grammar);
    if (nodeRule instanceof BeginWhileRule) {
      whileRules.push({
        rule: nodeRule,
        stack: node
      });
    }
  }
  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {
    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);
    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (r) {
      const matchedRuleId = r.ruleId;
      if (matchedRuleId !== whileRuleId) {
        stack = whileRule.stack.pop();
        break;
      }
      if (r.captureIndices && r.captureIndices.length) {
        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);
        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);
        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);
        anchorPosition = r.captureIndices[0].end;
        if (r.captureIndices[0].end > linePos) {
          linePos = r.captureIndices[0].end;
          isFirstLine = false;
        }
      }
    } else {
      stack = whileRule.stack.pop();
      break;
    }
  }
  return { stack, linePos, anchorPosition, isFirstLine };
}
function matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
  const injections = grammar.getInjections();
  if (injections.length === 0) {
    return matchResult;
  }
  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
  if (!injectionResult) {
    return matchResult;
  }
  if (!matchResult) {
    return injectionResult;
  }
  const matchResultScore = matchResult.captureIndices[0].start;
  const injectionResultScore = injectionResult.captureIndices[0].start;
  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {
    return injectionResult;
  }
  return matchResult;
}
function matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  const rule = stack.getRule(grammar);
  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);
  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
  if (r) {
    return {
      captureIndices: r.captureIndices,
      matchedRuleId: r.ruleId
    };
  }
  return null;
}
function matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  let bestMatchRating = Number.MAX_VALUE;
  let bestMatchCaptureIndices = null;
  let bestMatchRuleId;
  let bestMatchResultPriority = 0;
  const scopes = stack.contentNameScopesList.getScopeNames();
  for (let i = 0, len = injections.length; i < len; i++) {
    const injection = injections[i];
    if (!injection.matcher(scopes)) {
      continue;
    }
    const rule = grammar.getRule(injection.ruleId);
    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);
    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (!matchResult) {
      continue;
    }
    const matchRating = matchResult.captureIndices[0].start;
    if (matchRating >= bestMatchRating) {
      continue;
    }
    bestMatchRating = matchRating;
    bestMatchCaptureIndices = matchResult.captureIndices;
    bestMatchRuleId = matchResult.ruleId;
    bestMatchResultPriority = injection.priority;
    if (bestMatchRating === linePos) {
      break;
    }
  }
  if (bestMatchCaptureIndices) {
    return {
      priorityMatch: bestMatchResultPriority === -1,
      captureIndices: bestMatchCaptureIndices,
      matchedRuleId: bestMatchRuleId
    };
  }
  return null;
}
function prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {
  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);
  return {
    ruleScanner,
    findOptions: 0
    /* FindOption.None */
  };
}
function prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {
  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);
  return {
    ruleScanner,
    findOptions: 0
    /* FindOption.None */
  };
}
function handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {
  if (captures.length === 0) {
    return;
  }
  const lineTextContent = lineText.content;
  const len = Math.min(captures.length, captureIndices.length);
  const localStack = [];
  const maxEnd = captureIndices[0].end;
  for (let i = 0; i < len; i++) {
    const captureRule = captures[i];
    if (captureRule === null) {
      continue;
    }
    const captureIndex = captureIndices[i];
    if (captureIndex.length === 0) {
      continue;
    }
    if (captureIndex.start > maxEnd) {
      break;
    }
    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {
      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
      localStack.pop();
    }
    if (localStack.length > 0) {
      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);
    } else {
      lineTokens.produce(stack, captureIndex.start);
    }
    if (captureRule.retokenizeCapturedWithRuleId) {
      const scopeName = captureRule.getName(lineTextContent, captureIndices);
      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
      const contentName = captureRule.getContentName(lineTextContent, captureIndices);
      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);
      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));
      _tokenizeString(
        grammar,
        onigSubStr,
        isFirstLine && captureIndex.start === 0,
        captureIndex.start,
        stackClone,
        lineTokens,
        false,
        /* no time limit */
        0
      );
      disposeOnigString(onigSubStr);
      continue;
    }
    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);
    if (captureRuleScopeName !== null) {
      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;
      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);
      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));
    }
  }
  while (localStack.length > 0) {
    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
    localStack.pop();
  }
}
var LocalStackElement = class {
  constructor(scopes, endPos) {
    __publicField(this, "scopes");
    __publicField(this, "endPos");
    this.scopes = scopes;
    this.endPos = endPos;
  }
};
function createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {
  return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib);
}
function collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {
  const matchers = createMatchers(selector, nameMatcher);
  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);
  for (const matcher of matchers) {
    result.push({
      debugSelector: selector,
      matcher: matcher.matcher,
      ruleId,
      grammar,
      priority: matcher.priority
    });
  }
}
function nameMatcher(identifers, scopes) {
  if (scopes.length < identifers.length) {
    return false;
  }
  let lastIndex = 0;
  return identifers.every((identifier) => {
    for (let i = lastIndex; i < scopes.length; i++) {
      if (scopesAreMatching(scopes[i], identifier)) {
        lastIndex = i + 1;
        return true;
      }
    }
    return false;
  });
}
function scopesAreMatching(thisScopeName, scopeName) {
  if (!thisScopeName) {
    return false;
  }
  if (thisScopeName === scopeName) {
    return true;
  }
  const len = scopeName.length;
  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === ".";
}
var Grammar = class {
  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {
    __publicField(this, "_rootScopeName");
    __publicField(this, "balancedBracketSelectors");
    __publicField(this, "_onigLib");
    __publicField(this, "_rootId");
    __publicField(this, "_lastRuleId");
    __publicField(this, "_ruleId2desc");
    __publicField(this, "_includedGrammars");
    __publicField(this, "_grammarRepository");
    __publicField(this, "_grammar");
    __publicField(this, "_injections");
    __publicField(this, "_basicScopeAttributesProvider");
    __publicField(this, "_tokenTypeMatchers");
    this._rootScopeName = _rootScopeName;
    this.balancedBracketSelectors = balancedBracketSelectors;
    this._onigLib = _onigLib;
    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);
    this._rootId = -1;
    this._lastRuleId = 0;
    this._ruleId2desc = [null];
    this._includedGrammars = {};
    this._grammarRepository = grammarRepository;
    this._grammar = initGrammar(grammar, null);
    this._injections = null;
    this._tokenTypeMatchers = [];
    if (tokenTypes) {
      for (const selector of Object.keys(tokenTypes)) {
        const matchers = createMatchers(selector, nameMatcher);
        for (const matcher of matchers) {
          this._tokenTypeMatchers.push({
            matcher: matcher.matcher,
            type: tokenTypes[selector]
          });
        }
      }
    }
  }
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const rule of this._ruleId2desc) {
      if (rule) {
        rule.dispose();
      }
    }
  }
  createOnigScanner(sources) {
    return this._onigLib.createOnigScanner(sources);
  }
  createOnigString(sources) {
    return this._onigLib.createOnigString(sources);
  }
  getMetadataForScope(scope) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);
  }
  _collectInjections() {
    const grammarRepository = {
      lookup: (scopeName2) => {
        if (scopeName2 === this._rootScopeName) {
          return this._grammar;
        }
        return this.getExternalGrammar(scopeName2);
      },
      injections: (scopeName2) => {
        return this._grammarRepository.injections(scopeName2);
      }
    };
    const result = [];
    const scopeName = this._rootScopeName;
    const grammar = grammarRepository.lookup(scopeName);
    if (grammar) {
      const rawInjections = grammar.injections;
      if (rawInjections) {
        for (let expression in rawInjections) {
          collectInjections(result, expression, rawInjections[expression], this, grammar);
        }
      }
      const injectionScopeNames = this._grammarRepository.injections(scopeName);
      if (injectionScopeNames) {
        injectionScopeNames.forEach((injectionScopeName) => {
          const injectionGrammar = this.getExternalGrammar(injectionScopeName);
          if (injectionGrammar) {
            const selector = injectionGrammar.injectionSelector;
            if (selector) {
              collectInjections(result, selector, injectionGrammar, this, injectionGrammar);
            }
          }
        });
      }
    }
    result.sort((i1, i2) => i1.priority - i2.priority);
    return result;
  }
  getInjections() {
    if (this._injections === null) {
      this._injections = this._collectInjections();
    }
    return this._injections;
  }
  registerRule(factory) {
    const id = ++this._lastRuleId;
    const result = factory(ruleIdFromNumber(id));
    this._ruleId2desc[id] = result;
    return result;
  }
  getRule(ruleId) {
    return this._ruleId2desc[ruleIdToNumber(ruleId)];
  }
  getExternalGrammar(scopeName, repository) {
    if (this._includedGrammars[scopeName]) {
      return this._includedGrammars[scopeName];
    } else if (this._grammarRepository) {
      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);
      if (rawIncludedGrammar) {
        this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);
        return this._includedGrammars[scopeName];
      }
    }
    return void 0;
  }
  tokenizeLine(lineText, prevState, timeLimit = 0) {
    const r = this._tokenize(lineText, prevState, false, timeLimit);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(lineText, prevState, timeLimit = 0) {
    const r = this._tokenize(lineText, prevState, true, timeLimit);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {
    if (this._rootId === -1) {
      this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);
      this.getInjections();
    }
    let isFirstLine;
    if (!prevState || prevState === StateStackImpl.NULL) {
      isFirstLine = true;
      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();
      const defaultStyle = this.themeProvider.getDefaults();
      const defaultMetadata = EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);
      const rootScopeName = this.getRule(this._rootId).getName(null, null);
      let scopeList;
      if (rootScopeName) {
        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);
      } else {
        scopeList = AttributedScopeStack.createRoot("unknown", defaultMetadata);
      }
      prevState = new StateStackImpl(null, this._rootId, -1, -1, false, null, scopeList, scopeList);
    } else {
      isFirstLine = false;
      prevState.reset();
    }
    lineText = lineText + "\n";
    const onigLineText = this.createOnigString(lineText);
    const lineLength = onigLineText.content.length;
    const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);
    const r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);
    disposeOnigString(onigLineText);
    return {
      lineLength,
      lineTokens,
      ruleStack: r.stack,
      stoppedEarly: r.stoppedEarly
    };
  }
};
function initGrammar(grammar, base) {
  grammar = clone(grammar);
  grammar.repository = grammar.repository || {};
  grammar.repository.$self = {
    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,
    patterns: grammar.patterns,
    name: grammar.scopeName
  };
  grammar.repository.$base = base || grammar.repository.$self;
  return grammar;
}
var AttributedScopeStack = class _AttributedScopeStack {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(parent, scopePath, tokenAttributes) {
    __publicField(this, "parent");
    __publicField(this, "scopePath");
    __publicField(this, "tokenAttributes");
    this.parent = parent;
    this.scopePath = scopePath;
    this.tokenAttributes = tokenAttributes;
  }
  static fromExtension(namesScopeList, contentNameScopesList) {
    let current = namesScopeList;
    let scopeNames = (namesScopeList == null ? void 0 : namesScopeList.scopePath) ?? null;
    for (const frame of contentNameScopesList) {
      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);
      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);
    }
    return current;
  }
  static createRoot(scopeName, tokenAttributes) {
    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);
  }
  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {
    const rawRootMetadata = grammar.getMetadataForScope(scopeName);
    const scopePath = new ScopeStack(null, scopeName);
    const rootStyle = grammar.themeProvider.themeMatch(scopePath);
    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);
    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(other) {
    return _AttributedScopeStack.equals(this, other);
  }
  static equals(a, b) {
    do {
      if (a === b) {
        return true;
      }
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    } while (true);
  }
  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {
    let fontStyle = -1;
    let foreground = 0;
    let background = 0;
    if (styleAttributes !== null) {
      fontStyle = styleAttributes.fontStyle;
      foreground = styleAttributes.foregroundId;
      background = styleAttributes.backgroundId;
    }
    return EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);
  }
  pushAttributed(scopePath, grammar) {
    if (scopePath === null) {
      return this;
    }
    if (scopePath.indexOf(" ") === -1) {
      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);
    }
    const scopes = scopePath.split(/ /g);
    let result = this;
    for (const scope of scopes) {
      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);
    }
    return result;
  }
  static _pushAttributed(target, scopeName, grammar) {
    const rawMetadata = grammar.getMetadataForScope(scopeName);
    const newPath = target.scopePath.push(scopeName);
    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);
    const metadata = _AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);
    return new _AttributedScopeStack(target, newPath, metadata);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(base) {
    var _a;
    const result = [];
    let self = this;
    while (self && self !== base) {
      result.push({
        encodedTokenAttributes: self.tokenAttributes,
        scopeNames: self.scopePath.getExtensionIfDefined(((_a = self.parent) == null ? void 0 : _a.scopePath) ?? null)
      });
      self = self.parent;
    }
    return self === base ? result.reverse() : void 0;
  }
};
var _StateStackImpl = class _StateStackImpl2 {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
    __publicField(this, "parent");
    __publicField(this, "ruleId");
    __publicField(this, "beginRuleCapturedEOL");
    __publicField(this, "endRule");
    __publicField(this, "nameScopesList");
    __publicField(this, "contentNameScopesList");
    __publicField(this, "_stackElementBrand");
    __publicField(this, "_enterPos");
    __publicField(this, "_anchorPos");
    __publicField(this, "depth");
    this.parent = parent;
    this.ruleId = ruleId;
    this.beginRuleCapturedEOL = beginRuleCapturedEOL;
    this.endRule = endRule;
    this.nameScopesList = nameScopesList;
    this.contentNameScopesList = contentNameScopesList;
    this.depth = this.parent ? this.parent.depth + 1 : 1;
    this._enterPos = enterPos;
    this._anchorPos = anchorPos;
  }
  equals(other) {
    if (other === null) {
      return false;
    }
    return _StateStackImpl2._equals(this, other);
  }
  static _equals(a, b) {
    if (a === b) {
      return true;
    }
    if (!this._structuralEquals(a, b)) {
      return false;
    }
    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(a, b) {
    do {
      if (a === b) {
        return true;
      }
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    } while (true);
  }
  clone() {
    return this;
  }
  static _reset(el) {
    while (el) {
      el._enterPos = -1;
      el._anchorPos = -1;
      el = el.parent;
    }
  }
  reset() {
    _StateStackImpl2._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    if (this.parent) {
      return this.parent;
    }
    return this;
  }
  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
    return new _StateStackImpl2(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(grammar) {
    return grammar.getRule(this.ruleId);
  }
  toString() {
    const r = [];
    this._writeString(r, 0);
    return "[" + r.join(",") + "]";
  }
  _writeString(res, outIndex) {
    var _a, _b;
    if (this.parent) {
      outIndex = this.parent._writeString(res, outIndex);
    }
    res[outIndex++] = `(${this.ruleId}, ${(_a = this.nameScopesList) == null ? void 0 : _a.toString()}, ${(_b = this.contentNameScopesList) == null ? void 0 : _b.toString()})`;
    return outIndex;
  }
  withContentNameScopesList(contentNameScopeStack) {
    if (this.contentNameScopesList === contentNameScopeStack) {
      return this;
    }
    return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);
  }
  withEndRule(endRule) {
    if (this.endRule === endRule) {
      return this;
    }
    return new _StateStackImpl2(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);
  }
  // Used to warn of endless loops
  hasSameRuleAs(other) {
    let el = this;
    while (el && el._enterPos === other._enterPos) {
      if (el.ruleId === other.ruleId) {
        return true;
      }
      el = el.parent;
    }
    return false;
  }
  toStateStackFrame() {
    var _a, _b, _c;
    return {
      ruleId: ruleIdToNumber(this.ruleId),
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: ((_b = this.nameScopesList) == null ? void 0 : _b.getExtensionIfDefined(((_a = this.parent) == null ? void 0 : _a.nameScopesList) ?? null)) ?? [],
      contentNameScopesList: ((_c = this.contentNameScopesList) == null ? void 0 : _c.getExtensionIfDefined(this.nameScopesList)) ?? []
    };
  }
  static pushFrame(self, frame) {
    const namesScopeList = AttributedScopeStack.fromExtension((self == null ? void 0 : self.nameScopesList) ?? null, frame.nameScopesList);
    return new _StateStackImpl2(self, ruleIdFromNumber(frame.ruleId), frame.enterPos ?? -1, frame.anchorPos ?? -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));
  }
};
__publicField(_StateStackImpl, "NULL", new _StateStackImpl(null, 0, 0, 0, false, null, null, null));
var StateStackImpl = _StateStackImpl;
var BalancedBracketSelectors = class {
  constructor(balancedBracketScopes, unbalancedBracketScopes) {
    __publicField(this, "balancedBracketScopes");
    __publicField(this, "unbalancedBracketScopes");
    __publicField(this, "allowAny", false);
    this.balancedBracketScopes = balancedBracketScopes.flatMap((selector) => {
      if (selector === "*") {
        this.allowAny = true;
        return [];
      }
      return createMatchers(selector, nameMatcher).map((m) => m.matcher);
    });
    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher));
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(scopes) {
    for (const excluder of this.unbalancedBracketScopes) {
      if (excluder(scopes)) {
        return false;
      }
    }
    for (const includer of this.balancedBracketScopes) {
      if (includer(scopes)) {
        return true;
      }
    }
    return this.allowAny;
  }
};
var LineTokens = class {
  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {
    __publicField(this, "balancedBracketSelectors");
    __publicField(this, "_emitBinaryTokens");
    __publicField(this, "_lineText");
    __publicField(this, "_tokens");
    __publicField(this, "_binaryTokens");
    __publicField(this, "_lastTokenEndIndex");
    __publicField(this, "_tokenTypeOverrides");
    this.balancedBracketSelectors = balancedBracketSelectors;
    this._emitBinaryTokens = emitBinaryTokens;
    this._tokenTypeOverrides = tokenTypeOverrides;
    {
      this._lineText = null;
    }
    this._tokens = [];
    this._binaryTokens = [];
    this._lastTokenEndIndex = 0;
  }
  produce(stack, endIndex) {
    this.produceFromScopes(stack.contentNameScopesList, endIndex);
  }
  produceFromScopes(scopesList, endIndex) {
    var _a;
    if (this._lastTokenEndIndex >= endIndex) {
      return;
    }
    if (this._emitBinaryTokens) {
      let metadata = (scopesList == null ? void 0 : scopesList.tokenAttributes) ?? 0;
      let containsBalancedBrackets = false;
      if ((_a = this.balancedBracketSelectors) == null ? void 0 : _a.matchesAlways) {
        containsBalancedBrackets = true;
      }
      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const scopes2 = (scopesList == null ? void 0 : scopesList.getScopeNames()) ?? [];
        for (const tokenType of this._tokenTypeOverrides) {
          if (tokenType.matcher(scopes2)) {
            metadata = EncodedTokenAttributes.set(metadata, 0, toOptionalTokenType(tokenType.type), null, -1, 0, 0);
          }
        }
        if (this.balancedBracketSelectors) {
          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);
        }
      }
      if (containsBalancedBrackets) {
        metadata = EncodedTokenAttributes.set(metadata, 0, 8, containsBalancedBrackets, -1, 0, 0);
      }
      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {
        this._lastTokenEndIndex = endIndex;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex);
      this._binaryTokens.push(metadata);
      this._lastTokenEndIndex = endIndex;
      return;
    }
    const scopes = (scopesList == null ? void 0 : scopesList.getScopeNames()) ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes
    });
    this._lastTokenEndIndex = endIndex;
  }
  getResult(stack, lineLength) {
    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {
      this._tokens.pop();
    }
    if (this._tokens.length === 0) {
      this._lastTokenEndIndex = -1;
      this.produce(stack, lineLength);
      this._tokens[this._tokens.length - 1].startIndex = 0;
    }
    return this._tokens;
  }
  getBinaryResult(stack, lineLength) {
    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {
      this._binaryTokens.pop();
      this._binaryTokens.pop();
    }
    if (this._binaryTokens.length === 0) {
      this._lastTokenEndIndex = -1;
      this.produce(stack, lineLength);
      this._binaryTokens[this._binaryTokens.length - 2] = 0;
    }
    const result = new Uint32Array(this._binaryTokens.length);
    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {
      result[i] = this._binaryTokens[i];
    }
    return result;
  }
};
var SyncRegistry = class {
  constructor(theme, _onigLibPromise) {
    __publicField(this, "_onigLibPromise");
    __publicField(this, "_grammars", /* @__PURE__ */ new Map());
    __publicField(this, "_rawGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_injectionGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_theme");
    this._onigLibPromise = _onigLibPromise;
    this._theme = theme;
  }
  dispose() {
    for (const grammar of this._grammars.values()) {
      grammar.dispose();
    }
  }
  setTheme(theme) {
    this._theme = theme;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(grammar, injectionScopeNames) {
    this._rawGrammars.set(grammar.scopeName, grammar);
    if (injectionScopeNames) {
      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);
    }
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(scopeName) {
    return this._rawGrammars.get(scopeName);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(targetScope) {
    return this._injectionGrammars.get(targetScope);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(scopePath) {
    return this._theme.match(scopePath);
  }
  /**
   * Lookup a grammar.
   */
  async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
    if (!this._grammars.has(scopeName)) {
      let rawGrammar = this._rawGrammars.get(scopeName);
      if (!rawGrammar) {
        return null;
      }
      this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));
    }
    return this._grammars.get(scopeName);
  }
};
var Registry$1 = class Registry {
  constructor(options) {
    __publicField(this, "_options");
    __publicField(this, "_syncRegistry");
    __publicField(this, "_ensureGrammarCache");
    this._options = options;
    this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);
    this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(theme, colorMap) {
    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {
    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {
    return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(initialScopeName) {
    return this._loadGrammar(initialScopeName, 0, null, null, null);
  }
  async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);
    while (dependencyProcessor.Q.length > 0) {
      await Promise.all(dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName)));
      dependencyProcessor.processQueue();
    }
    return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
  }
  async _loadSingleGrammar(scopeName) {
    if (!this._ensureGrammarCache.has(scopeName)) {
      this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName));
    }
    return this._ensureGrammarCache.get(scopeName);
  }
  async _doLoadSingleGrammar(scopeName) {
    const grammar = await this._options.loadGrammar(scopeName);
    if (grammar) {
      const injections = typeof this._options.getInjections === "function" ? this._options.getInjections(scopeName) : void 0;
      this._syncRegistry.addGrammar(grammar, injections);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {
    this._syncRegistry.addGrammar(rawGrammar, injections);
    return await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {
    return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
  }
};
var INITIAL = StateStackImpl.NULL;
var MetadataConsts = {
  LANGUAGEID_MASK: 255,
  TOKEN_TYPE_MASK: 768,
  BALANCED_BRACKETS_MASK: 1024,
  FONT_STYLE_MASK: 14336,
  FOREGROUND_MASK: 8372224,
  BACKGROUND_MASK: 4286578688,
  LANGUAGEID_OFFSET: 0,
  TOKEN_TYPE_OFFSET: 8,
  BALANCED_BRACKETS_OFFSET: 10,
  FONT_STYLE_OFFSET: 11,
  FOREGROUND_OFFSET: 15,
  BACKGROUND_OFFSET: 24
};
var StackElementMetadata = class _StackElementMetadata {
  static toBinaryStr(metadata) {
    let r = metadata.toString(2);
    while (r.length < 32)
      r = `0${r}`;
    return r;
  }
  // public static printMetadata(metadata: number): void {
  //   const languageId = StackElementMetadata.getLanguageId(metadata)
  //   const tokenType = StackElementMetadata.getTokenType(metadata)
  //   const fontStyle = StackElementMetadata.getFontStyle(metadata)
  //   const foreground = StackElementMetadata.getForeground(metadata)
  //   const background = StackElementMetadata.getBackground(metadata)
  //   console.log({
  //     languageId,
  //     tokenType,
  //     fontStyle,
  //     foreground,
  //     background,
  //   })
  // }
  static getLanguageId(metadata) {
    return (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;
  }
  static getTokenType(metadata) {
    return (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;
  }
  static getFontStyle(metadata) {
    return (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;
  }
  static getForeground(metadata) {
    return (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;
  }
  static getBackground(metadata) {
    return (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;
  }
  static containsBalancedBrackets(metadata) {
    return (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;
  }
  static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
    let _languageId = _StackElementMetadata.getLanguageId(metadata);
    let _tokenType = _StackElementMetadata.getTokenType(metadata);
    let _fontStyle = _StackElementMetadata.getFontStyle(metadata);
    let _foreground = _StackElementMetadata.getForeground(metadata);
    let _background = _StackElementMetadata.getBackground(metadata);
    const _containsBalancedBracketsBit = _StackElementMetadata.containsBalancedBrackets(metadata) ? 1 : 0;
    if (languageId !== 0)
      _languageId = languageId;
    if (tokenType !== 0) {
      _tokenType = tokenType === 8 ? 0 : tokenType;
    }
    if (fontStyle !== FontStyle.NotSet)
      _fontStyle = fontStyle;
    if (foreground !== 0)
      _foreground = foreground;
    if (background !== 0)
      _background = background;
    return (_languageId << MetadataConsts.LANGUAGEID_OFFSET | _tokenType << MetadataConsts.TOKEN_TYPE_OFFSET | _fontStyle << MetadataConsts.FONT_STYLE_OFFSET | _containsBalancedBracketsBit << MetadataConsts.BALANCED_BRACKETS_OFFSET | _foreground << MetadataConsts.FOREGROUND_OFFSET | _background << MetadataConsts.BACKGROUND_OFFSET) >>> 0;
  }
};
function splitLines(code2, preserveEnding = false) {
  var _a;
  const parts = code2.split(/(\r?\n)/g);
  let index = 0;
  const lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index]);
    index += parts[i].length;
    index += ((_a = parts[i + 1]) == null ? void 0 : _a.length) || 0;
  }
  return lines;
}
function isPlainLang(lang) {
  return !lang || ["plaintext", "txt", "text", "plain"].includes(lang);
}
function isSpecialLang(lang) {
  return lang === "ansi" || isPlainLang(lang);
}
function isNoneTheme(theme) {
  return theme === "none";
}
function isSpecialTheme(theme) {
  return isNoneTheme(theme);
}
function addClassToHast(node, className) {
  var _a;
  if (!className)
    return node;
  node.properties || (node.properties = {});
  (_a = node.properties).class || (_a.class = []);
  if (typeof node.properties.class === "string")
    node.properties.class = node.properties.class.split(/\s+/g);
  if (!Array.isArray(node.properties.class))
    node.properties.class = [];
  const targets = Array.isArray(className) ? className : className.split(/\s+/g);
  for (const c of targets) {
    if (c && !node.properties.class.includes(c))
      node.properties.class.push(c);
  }
  return node;
}
function splitToken(token, offsets) {
  let lastOffset = 0;
  const tokens = [];
  for (const offset of offsets) {
    if (offset > lastOffset) {
      tokens.push({
        ...token,
        content: token.content.slice(lastOffset, offset),
        offset: token.offset + lastOffset
      });
    }
    lastOffset = offset;
  }
  if (lastOffset < token.content.length) {
    tokens.push({
      ...token,
      content: token.content.slice(lastOffset),
      offset: token.offset + lastOffset
    });
  }
  return tokens;
}
function splitTokens(tokens, breakpoints) {
  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  if (!sorted.length)
    return tokens;
  return tokens.map((line) => {
    return line.flatMap((token) => {
      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);
      if (!breakpointsInToken.length)
        return token;
      return splitToken(token, breakpointsInToken);
    });
  });
}
function resolveColorReplacements(theme, options) {
  const replacements = typeof theme === "string" ? {} : { ...theme.colorReplacements };
  const themeName = typeof theme === "string" ? theme : theme.name;
  for (const [key2, value] of Object.entries((options == null ? void 0 : options.colorReplacements) || {})) {
    if (typeof value === "string")
      replacements[key2] = value;
    else if (key2 === themeName)
      Object.assign(replacements, value);
  }
  return replacements;
}
function applyColorReplacements(color, replacements) {
  if (!color)
    return color;
  return (replacements == null ? void 0 : replacements[color == null ? void 0 : color.toLowerCase()]) || color;
}
function getTokenStyleObject(token) {
  const styles = {};
  if (token.color)
    styles.color = token.color;
  if (token.bgColor)
    styles["background-color"] = token.bgColor;
  if (token.fontStyle) {
    if (token.fontStyle & FontStyle.Italic)
      styles["font-style"] = "italic";
    if (token.fontStyle & FontStyle.Bold)
      styles["font-weight"] = "bold";
    if (token.fontStyle & FontStyle.Underline)
      styles["text-decoration"] = "underline";
  }
  return styles;
}
function stringifyTokenStyle(token) {
  return Object.entries(token).map(([key2, value]) => `${key2}:${value}`).join(";");
}
function createPositionConverter(code2) {
  const lines = splitLines(code2, true).map(([line]) => line);
  function indexToPos(index) {
    let character = index;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index = 0;
    for (let i = 0; i < line; i++)
      index += lines[i].length;
    index += character;
    return index;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function findSequence(value, position) {
  const nextEscape = value.indexOf("\x1B[", position);
  if (nextEscape !== -1) {
    const nextClose = value.indexOf("m", nextEscape);
    return {
      sequence: value.substring(nextEscape + 2, nextClose).split(";"),
      startPosition: nextEscape,
      position: nextClose + 1
    };
  }
  return {
    position: value.length
  };
}
function parseColor(sequence, index) {
  let offset = 1;
  const colorMode = sequence[index + offset++];
  let color;
  if (colorMode === "2") {
    const rgb = [
      sequence[index + offset++],
      sequence[index + offset++],
      sequence[index + offset]
    ].map((x) => Number.parseInt(x));
    if (rgb.length === 3 && !rgb.some((x) => Number.isNaN(x))) {
      color = {
        type: "rgb",
        rgb
      };
    }
  } else if (colorMode === "5") {
    const colorIndex = Number.parseInt(sequence[index + offset]);
    if (!Number.isNaN(colorIndex)) {
      color = { type: "table", index: Number(colorIndex) };
    }
  }
  return [offset, color];
}
function parseSequence(sequence) {
  const commands = [];
  for (let i = 0; i < sequence.length; i++) {
    const code2 = sequence[i];
    const codeInt = Number.parseInt(code2);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const [offset, color] = parseColor(sequence, i);
      if (color) {
        commands.push({
          type: "setForegroundColor",
          value: color
        });
      }
      i += offset;
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const [offset, color] = parseColor(sequence, i);
      if (color) {
        commands.push({
          type: "setBackgroundColor",
          value: color
        });
      }
      i += offset;
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position = 0;
      do {
        const findResult = findSequence(value, position);
        const text2 = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text2.length > 0) {
          tokens.push({
            value: text2,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index) {
    return getColorTable()[index];
  }
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return {
    value
  };
}
function tokenizeAnsiWithTheme(theme, fileContents, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const lines = splitLines(fileContents);
  const colorPalette = createColorPalette(Object.fromEntries(namedColors.map((name) => {
    var _a;
    return [
      name,
      (_a = theme.colors) == null ? void 0 : _a[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]
    ];
  })));
  const parser = createAnsiSequenceParser();
  return lines.map((line) => parser.parse(line[0]).map((token) => {
    let color;
    let bgColor;
    if (token.decorations.has("reverse")) {
      color = token.background ? colorPalette.value(token.background) : theme.bg;
      bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
    } else {
      color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
      bgColor = token.background ? colorPalette.value(token.background) : void 0;
    }
    color = applyColorReplacements(color, colorReplacements);
    bgColor = applyColorReplacements(bgColor, colorReplacements);
    if (token.decorations.has("dim"))
      color = dimColor(color);
    let fontStyle = FontStyle.None;
    if (token.decorations.has("bold"))
      fontStyle |= FontStyle.Bold;
    if (token.decorations.has("italic"))
      fontStyle |= FontStyle.Italic;
    if (token.decorations.has("underline"))
      fontStyle |= FontStyle.Underline;
    return {
      content: token.value,
      offset: line[1],
      // TODO: more accurate offset? might need to fork ansi-sequence-parser
      color,
      bgColor,
      fontStyle
    };
  }));
}
function dimColor(color) {
  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) {
    if (hexMatch[3]) {
      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
    } else if (hexMatch[2]) {
      return `#${hexMatch[1]}${hexMatch[2]}80`;
    } else {
      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join("")}80`;
    }
  }
  const cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  if (cssVarMatch)
    return `var(${cssVarMatch[1]}-dim)`;
  return color;
}
var ShikiError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
var GrammarState = class {
  constructor(_stack, lang, theme) {
    __publicField(this, "_stack");
    __publicField(this, "lang");
    __publicField(this, "theme");
    this._stack = _stack;
    this.lang = lang;
    this.theme = theme;
  }
  get scopes() {
    return getScopes(this._stack);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      scopes: this.scopes
    };
  }
};
function getScopes(stack) {
  const scopes = [];
  const visited = /* @__PURE__ */ new Set();
  function pushScope(stack2) {
    var _a;
    if (visited.has(stack2))
      return;
    visited.add(stack2);
    const name = (_a = stack2 == null ? void 0 : stack2.nameScopesList) == null ? void 0 : _a.scopeName;
    if (name)
      scopes.push(name);
    if (stack2.parent)
      pushScope(stack2.parent);
  }
  pushScope(stack);
  return scopes;
}
function getGrammarStack(state) {
  if (!(state instanceof GrammarState))
    throw new ShikiError("Invalid grammar state");
  return state._stack;
}
function codeToTokensBase(internal, code2, options = {}) {
  const { lang = "text", theme: themeName = internal.getLoadedThemes()[0] } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    return splitLines(code2).map((line) => [{ content: line[0], offset: line[1] }]);
  const { theme, colorMap } = internal.setTheme(themeName);
  if (lang === "ansi")
    return tokenizeAnsiWithTheme(theme, code2, options);
  const _grammar = internal.getLanguage(lang);
  if (options.grammarState) {
    if (options.grammarState.lang !== _grammar.name) {
      throw new ShikiError(`Grammar state language "${options.grammarState.lang}" does not match highlight language "${_grammar.name}"`);
    }
    if (options.grammarState.theme !== themeName) {
      throw new ShikiError(`Grammar state theme "${options.grammarState.theme}" does not match highlight theme "${themeName}"`);
    }
  }
  return tokenizeWithTheme(code2, _grammar, theme, colorMap, options);
}
function getLastGrammarState(internal, code2, options = {}) {
  const { lang = "text", theme: themeName = internal.getLoadedThemes()[0] } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    throw new ShikiError("Plain language does not have grammar state");
  if (lang === "ansi")
    throw new ShikiError("ANSI language does not have grammar state");
  const { theme, colorMap } = internal.setTheme(themeName);
  const _grammar = internal.getLanguage(lang);
  return new GrammarState(_tokenizeWithTheme(code2, _grammar, theme, colorMap, options).stateStack, _grammar.name, theme.name);
}
function tokenizeWithTheme(code2, grammar, theme, colorMap, options) {
  return _tokenizeWithTheme(code2, grammar, theme, colorMap, options).tokens;
}
function _tokenizeWithTheme(code2, grammar, theme, colorMap, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const { tokenizeMaxLineLength = 0, tokenizeTimeLimit = 500 } = options;
  const lines = splitLines(code2);
  let stateStack = options.grammarState ? getGrammarStack(options.grammarState) : options.grammarContextCode != null ? _tokenizeWithTheme(options.grammarContextCode, grammar, theme, colorMap, {
    ...options,
    grammarState: void 0,
    grammarContextCode: void 0
  }).stateStack : INITIAL;
  let actual = [];
  const final = [];
  const themeSettingsSelectors = [];
  if (options.includeExplanation) {
    for (const setting of theme.settings) {
      let selectors;
      switch (typeof setting.scope) {
        case "string":
          selectors = setting.scope.split(/,/).map((scope) => scope.trim());
          break;
        case "object":
          selectors = setting.scope;
          break;
        default:
          continue;
      }
      themeSettingsSelectors.push({
        settings: setting,
        selectors: selectors.map((selector) => selector.split(/ /))
      });
    }
  }
  for (let i = 0, len = lines.length; i < len; i++) {
    const [line, lineOffset] = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
      actual = [];
      final.push([{
        content: line,
        offset: lineOffset,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, stateStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);
    const tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      const startIndex = result.tokens[2 * j];
      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex)
        continue;
      const metadata = result.tokens[2 * j + 1];
      const color = applyColorReplacements(colorMap[StackElementMetadata.getForeground(metadata)], colorReplacements);
      const fontStyle = StackElementMetadata.getFontStyle(metadata);
      const token = {
        content: line.substring(startIndex, nextStartIndex),
        offset: lineOffset + startIndex,
        color,
        fontStyle
      };
      if (options.includeExplanation) {
        token.explanation = [];
        let offset = 0;
        while (startIndex + offset < nextStartIndex) {
          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          const tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
          offset += tokenWithScopesText.length;
          token.explanation.push({
            content: tokenWithScopesText,
            scopes: explainThemeScopes(themeSettingsSelectors, tokenWithScopes.scopes)
          });
          tokensWithScopesIndex += 1;
        }
      }
      actual.push(token);
    }
    final.push(actual);
    actual = [];
    stateStack = result.ruleStack;
  }
  return {
    tokens: final,
    stateStack
  };
}
function explainThemeScopes(themeSelectors, scopes) {
  const result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    const parentScopes = scopes.slice(0, i);
    const scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(themeSelectors, scope, parentScopes)
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
}
function matches(selectors, scope, parentScopes) {
  if (!matchesOne(selectors[selectors.length - 1], scope))
    return false;
  let selectorParentIndex = selectors.length - 2;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))
      selectorParentIndex -= 1;
    parentIndex -= 1;
  }
  if (selectorParentIndex === -1)
    return true;
  return false;
}
function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
  const result = [];
  for (const { selectors, settings } of themeSettingsSelectors) {
    for (const selectorPieces of selectors) {
      if (matches(selectorPieces, scope, parentScopes)) {
        result.push(settings);
        break;
      }
    }
  }
  return result;
}
function codeToTokensWithThemes(internal, code2, options) {
  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));
  const tokens = syncThemesTokenization(...themes.map((t) => codeToTokensBase(internal, code2, {
    ...options,
    theme: t.theme
  })));
  const mergedTokens = tokens[0].map((line, lineIdx) => line.map((_token, tokenIdx) => {
    const mergedToken = {
      content: _token.content,
      variants: {},
      offset: _token.offset
    };
    tokens.forEach((t, themeIdx) => {
      const { content: _, explanation: __, offset: ___, ...styles } = t[lineIdx][tokenIdx];
      mergedToken.variants[themes[themeIdx].color] = styles;
    });
    return mergedToken;
  }));
  return mergedTokens;
}
function syncThemesTokenization(...themes) {
  const outThemes = themes.map(() => []);
  const count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    const lines = themes.map((t) => t[i]);
    const outLines = outThemes.map(() => []);
    outThemes.forEach((t, i2) => t.push(outLines[i2]));
    const indexes = lines.map(() => 0);
    const current = lines.map((l) => l[0]);
    while (current.every((t) => t)) {
      const minLength = Math.min(...current.map((t) => t.content.length));
      for (let n = 0; n < count; n++) {
        const token = current[n];
        if (token.content.length === minLength) {
          outLines[n].push(token);
          indexes[n] += 1;
          current[n] = lines[n][indexes[n]];
        } else {
          outLines[n].push({
            ...token,
            content: token.content.slice(0, minLength)
          });
          current[n] = {
            ...token,
            content: token.content.slice(minLength),
            offset: token.offset + minLength
          };
        }
      }
    }
  }
  return outThemes;
}
function codeToTokens(internal, code2, options) {
  let bg;
  let fg;
  let tokens;
  let themeName;
  let rootStyle;
  if ("themes" in options) {
    const { defaultColor = "light", cssVariablePrefix = "--shiki-" } = options;
    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0)
      throw new ShikiError("`themes` option must not be empty");
    const themeTokens = codeToTokensWithThemes(internal, code2, options);
    if (defaultColor && !themes.find((t) => t.color === defaultColor))
      throw new ShikiError(`\`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    const themeRegs = themes.map((t) => internal.getTheme(t.theme));
    const themesOrder = themes.map((t) => t.color);
    tokens = themeTokens.map((line) => line.map((token) => mergeToken(token, themesOrder, cssVariablePrefix, defaultColor)));
    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));
    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || "inherit")).join(";");
    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || "inherit")).join(";");
    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(" ")}`;
    rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    const colorReplacements = resolveColorReplacements(options.theme, options.colorReplacements);
    tokens = codeToTokensBase(internal, code2, options);
    const _theme = internal.getTheme(options.theme);
    bg = applyColorReplacements(_theme.bg, colorReplacements);
    fg = applyColorReplacements(_theme.fg, colorReplacements);
    themeName = _theme.name;
  } else {
    throw new ShikiError("Invalid options, either `theme` or `themes` must be provided");
  }
  return {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle
  };
}
function mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {
  const token = {
    content: merged.content,
    explanation: merged.explanation,
    offset: merged.offset
  };
  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));
  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));
  const mergedStyles = styles.reduce((acc, cur, idx) => {
    for (const key2 of styleKeys) {
      const value = cur[key2] || "inherit";
      if (idx === 0 && defaultColor) {
        acc[key2] = value;
      } else {
        const keyName = key2 === "color" ? "" : key2 === "background-color" ? "-bg" : `-${key2}`;
        const varKey = cssVariablePrefix + variantsOrder[idx] + (key2 === "color" ? "" : keyName);
        if (acc[key2])
          acc[key2] += `;${varKey}:${value}`;
        else
          acc[key2] = `${varKey}:${value}`;
      }
    }
    return acc;
  }, {});
  token.htmlStyle = defaultColor ? stringifyTokenStyle(mergedStyles) : Object.values(mergedStyles).join(";");
  return token;
}
function transformerDecorations() {
  const map = /* @__PURE__ */ new WeakMap();
  function getContext(shiki) {
    if (!map.has(shiki.meta)) {
      let normalizePosition = function(p2) {
        if (typeof p2 === "number") {
          return {
            ...converter.indexToPos(p2),
            offset: p2
          };
        } else {
          return {
            ...p2,
            offset: converter.posToIndex(p2.line, p2.character)
          };
        }
      };
      const converter = createPositionConverter(shiki.source);
      const decorations2 = (shiki.options.decorations || []).map((d) => ({
        ...d,
        start: normalizePosition(d.start),
        end: normalizePosition(d.end)
      }));
      verifyIntersections(decorations2);
      map.set(shiki.meta, {
        decorations: decorations2,
        converter,
        source: shiki.source
      });
    }
    return map.get(shiki.meta);
  }
  function verifyIntersections(items) {
    for (let i = 0; i < items.length; i++) {
      const foo = items[i];
      if (foo.start.offset > foo.end.offset)
        throw new ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);
      for (let j = i + 1; j < items.length; j++) {
        const bar = items[j];
        const isFooHasBarStart = foo.start.offset < bar.start.offset && bar.start.offset < foo.end.offset;
        const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset < foo.end.offset;
        const isBarHasFooStart = bar.start.offset < foo.start.offset && foo.start.offset < bar.end.offset;
        const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset < bar.end.offset;
        if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
          if (isFooHasBarEnd && isFooHasBarEnd)
            continue;
          if (isBarHasFooStart && isBarHasFooEnd)
            continue;
          throw new ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);
        }
      }
    }
  }
  return {
    name: "shiki:decorations",
    tokens(tokens) {
      var _a;
      if (!((_a = this.options.decorations) == null ? void 0 : _a.length))
        return;
      const ctx = getContext(this);
      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);
      const splitted = splitTokens(tokens, breakpoints);
      return splitted;
    },
    code(codeEl) {
      var _a;
      if (!((_a = this.options.decorations) == null ? void 0 : _a.length))
        return;
      const ctx = getContext(this);
      const lines = Array.from(codeEl.children).filter((i) => i.type === "element" && i.tagName === "span");
      if (lines.length !== ctx.converter.lines.length)
        throw new ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);
      function applyLineSection(line, start, end, decoration) {
        const lineEl = lines[line];
        let text2 = "";
        let startIndex = -1;
        let endIndex = -1;
        function stringify2(el) {
          if (el.type === "text")
            return el.value;
          if (el.type === "element")
            return el.children.map(stringify2).join("");
          return "";
        }
        if (start === 0)
          startIndex = 0;
        if (end === 0)
          endIndex = 0;
        if (end === Number.POSITIVE_INFINITY)
          endIndex = lineEl.children.length;
        if (startIndex === -1 || endIndex === -1) {
          for (let i = 0; i < lineEl.children.length; i++) {
            text2 += stringify2(lineEl.children[i]);
            if (startIndex === -1 && text2.length === start)
              startIndex = i + 1;
            if (endIndex === -1 && text2.length === end)
              endIndex = i + 1;
          }
        }
        if (startIndex === -1)
          throw new ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);
        if (endIndex === -1)
          throw new ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);
        const children = lineEl.children.slice(startIndex, endIndex);
        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {
          applyDecoration(lineEl, decoration, "line");
        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") {
          applyDecoration(children[0], decoration, "token");
        } else {
          const wrapper = {
            type: "element",
            tagName: "span",
            properties: {},
            children
          };
          applyDecoration(wrapper, decoration, "wrapper");
          lineEl.children.splice(startIndex, children.length, wrapper);
        }
      }
      function applyLine(line, decoration) {
        lines[line] = applyDecoration(lines[line], decoration, "line");
      }
      function applyDecoration(el, decoration, type) {
        var _a2;
        const properties = decoration.properties || {};
        const transform = decoration.transform || ((i) => i);
        el.tagName = decoration.tagName || "span";
        el.properties = {
          ...el.properties,
          ...properties,
          class: el.properties.class
        };
        if ((_a2 = decoration.properties) == null ? void 0 : _a2.class)
          addClassToHast(el, decoration.properties.class);
        el = transform(el, type) || el;
        return el;
      }
      const lineApplies = [];
      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset);
      for (const decoration of sorted) {
        const { start, end } = decoration;
        if (start.line === end.line) {
          applyLineSection(start.line, start.character, end.character, decoration);
        } else if (start.line < end.line) {
          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
          for (let i = start.line + 1; i < end.line; i++)
            lineApplies.unshift(() => applyLine(i, decoration));
          applyLineSection(end.line, 0, end.character, decoration);
        }
      }
      lineApplies.forEach((i) => i());
    }
  };
}
var builtInTransformers = [
  transformerDecorations()
];
function getTransformers(options) {
  return [
    ...options.transformers || [],
    ...builtInTransformers
  ];
}
function codeToHast(internal, code2, options, transformerContext = {
  meta: {},
  options,
  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
}) {
  var _a, _b;
  let input = code2;
  for (const transformer of getTransformers(options))
    input = ((_a = transformer.preprocess) == null ? void 0 : _a.call(transformerContext, input, options)) || input;
  let { tokens, fg, bg, themeName, rootStyle } = codeToTokens(internal, input, options);
  const { mergeWhitespaces = true } = options;
  if (mergeWhitespaces === true)
    tokens = mergeWhitespaceTokens(tokens);
  else if (mergeWhitespaces === "never")
    tokens = splitWhitespaceTokens(tokens);
  const contextSource = {
    ...transformerContext,
    get source() {
      return input;
    }
  };
  for (const transformer of getTransformers(options))
    tokens = ((_b = transformer.tokens) == null ? void 0 : _b.call(contextSource, tokens)) || tokens;
  return tokensToHast(tokens, {
    ...options,
    fg,
    bg,
    themeName,
    rootStyle
  }, contextSource);
}
function tokensToHast(tokens, options, transformerContext) {
  var _a, _b, _c;
  const transformers = getTransformers(options);
  const lines = [];
  const root2 = {
    type: "root",
    children: []
  };
  const { structure = "classic" } = options;
  let preNode = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${options.themeName || ""}`,
      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,
      tabindex: "0",
      ...Object.fromEntries(Array.from(Object.entries(options.meta || {})).filter(([key2]) => !key2.startsWith("_")))
    },
    children: []
  };
  let codeNode = {
    type: "element",
    tagName: "code",
    properties: {},
    children: lines
  };
  const lineNodes = [];
  const context = {
    ...transformerContext,
    structure,
    addClassToHast,
    get source() {
      return transformerContext.source;
    },
    get tokens() {
      return tokens;
    },
    get options() {
      return options;
    },
    get root() {
      return root2;
    },
    get pre() {
      return preNode;
    },
    get code() {
      return codeNode;
    },
    get lines() {
      return lineNodes;
    }
  };
  tokens.forEach((line, idx) => {
    var _a2, _b2;
    if (idx) {
      if (structure === "inline")
        root2.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      else if (structure === "classic")
        lines.push({ type: "text", value: "\n" });
    }
    let lineNode = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    let col = 0;
    for (const token of line) {
      let tokenNode = {
        type: "element",
        tagName: "span",
        properties: {},
        children: [{ type: "text", value: token.content }]
      };
      const style = token.htmlStyle || stringifyTokenStyle(getTokenStyleObject(token));
      if (style)
        tokenNode.properties.style = style;
      for (const transformer of transformers)
        tokenNode = ((_a2 = transformer == null ? void 0 : transformer.span) == null ? void 0 : _a2.call(context, tokenNode, idx + 1, col, lineNode)) || tokenNode;
      if (structure === "inline")
        root2.children.push(tokenNode);
      else if (structure === "classic")
        lineNode.children.push(tokenNode);
      col += token.content.length;
    }
    if (structure === "classic") {
      for (const transformer of transformers)
        lineNode = ((_b2 = transformer == null ? void 0 : transformer.line) == null ? void 0 : _b2.call(context, lineNode, idx + 1)) || lineNode;
      lineNodes.push(lineNode);
      lines.push(lineNode);
    }
  });
  if (structure === "classic") {
    for (const transformer of transformers)
      codeNode = ((_a = transformer == null ? void 0 : transformer.code) == null ? void 0 : _a.call(context, codeNode)) || codeNode;
    preNode.children.push(codeNode);
    for (const transformer of transformers)
      preNode = ((_b = transformer == null ? void 0 : transformer.pre) == null ? void 0 : _b.call(context, preNode)) || preNode;
    root2.children.push(preNode);
  }
  let result = root2;
  for (const transformer of transformers)
    result = ((_c = transformer == null ? void 0 : transformer.root) == null ? void 0 : _c.call(context, result)) || result;
  return result;
}
function mergeWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    let carryOnContent = "";
    let firstOffset = 0;
    line.forEach((token, idx) => {
      const isUnderline = token.fontStyle && token.fontStyle & FontStyle.Underline;
      const couldMerge = !isUnderline;
      if (couldMerge && token.content.match(/^\s+$/) && line[idx + 1]) {
        if (!firstOffset)
          firstOffset = token.offset;
        carryOnContent += token.content;
      } else {
        if (carryOnContent) {
          if (couldMerge) {
            newLine.push({
              ...token,
              offset: firstOffset,
              content: carryOnContent + token.content
            });
          } else {
            newLine.push({
              content: carryOnContent,
              offset: firstOffset
            }, token);
          }
          firstOffset = 0;
          carryOnContent = "";
        } else {
          newLine.push(token);
        }
      }
    });
    return newLine;
  });
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token) => {
      if (token.content.match(/^\s+$/))
        return token;
      const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token;
      const [, leading, content, trailing] = match;
      if (!leading && !trailing)
        return token;
      const expanded = [{
        ...token,
        offset: token.offset + leading.length,
        content
      }];
      if (leading) {
        expanded.unshift({
          content: leading,
          offset: token.offset
        });
      }
      if (trailing) {
        expanded.push({
          content: trailing,
          offset: token.offset + leading.length + content.length
        });
      }
      return expanded;
    });
  });
}
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var Schema = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
};
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space) {
  const property = {};
  const normal = {};
  let index = -1;
  while (++index < definitions.length) {
    Object.assign(property, definitions[index].property);
    Object.assign(normal, definitions[index].normal);
  }
  return new Schema(property, normal, space);
}
function normalize(value) {
  return value.toLowerCase();
}
var Info = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
var types = Object.freeze({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
});
var checks = Object.keys(types);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space) {
    let index = -1;
    super(property, attribute);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index < checks.length) {
        const check = checks[index];
        mark(this, checks[index], (mask & types[check]) === types[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
var own$3 = {}.hasOwnProperty;
function create(definition) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition.properties) {
    if (own$3.call(definition.properties, prop)) {
      const value = definition.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition.transform(definition.attributes || {}, prop),
        value,
        definition.space
      );
      if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize(prop)] = prop;
      normal[normalize(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition.space);
}
var xlink = create({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
var xml = create({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
var xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
var aria = create({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
var html$3 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
var svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var html$2 = merge([xml, xlink, xmlns, aria, html$3], "html");
var svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
var own$2 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own$2.call(value, key2)) {
      const id = String(value[key2]);
      fn = own$2.call(handlers, id) ? handlers[id] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index + 2),
      options
    );
  }
  function basic(character, index, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index = -1;
  while (++index < subset.length) {
    groups.push(subset[index].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal(code2, next, omit) {
  const value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal(code2, next, omit) {
  const value = "&#" + String(code2);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var own$1 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own$1.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
function toNamed(code2, next, omit, attribute) {
  const character = String.fromCharCode(code2);
  if (own$1.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart(code2, next, options) {
  let numeric = toHexadecimal(code2, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code2,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code2, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}
var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
var bogusCommentEntitySubset = [">"];
var commentEntitySubset = ["<", ">"];
function comment(node, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: bogusCommentEntitySubset
    })
  ) + ">" : "<!--" + node.value.replace(htmlCommentRegex, encode) + "-->";
  function encode($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: commentEntitySubset
      })
    );
  }
}
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index = source.indexOf(character);
  while (index !== -1) {
    count++;
    index = source.indexOf(character, index + character.length);
  }
  return count;
}
function stringify$1(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
function stringify(values) {
  return values.join(" ").trim();
}
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren$1 = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$1;
    let offset = (index || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
var own = {}.hasOwnProperty;
function omission(handlers) {
  return omit;
  function omit(node, index, parent) {
    return own.call(handlers, node.tagName) && handlers[node.tagName](node, index, parent);
  }
}
var closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html$1,
  li,
  optgroup,
  option,
  p,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index, parent) {
  const next = siblingAfter(parent, index, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
}
function body$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
}
function p(_, index, parent) {
  const next = siblingAfter(parent, index);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index, parent) {
  const next = siblingAfter(parent, index);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index, parent) {
  const next = siblingAfter(parent, index);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index, parent) {
  return !siblingAfter(parent, index);
}
function tr(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
var opening = omission({
  body,
  colgroup,
  head,
  html,
  tbody
});
function html(node) {
  const head2 = siblingAfter(node, -1);
  return !head2 || head2.type !== "comment";
}
function head(node) {
  const children = node.children;
  const seen = [];
  let index = -1;
  while (++index < children.length) {
    const child = children[index];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName)) return false;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
}
function body(node) {
  const head2 = siblingAfter(node, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node, index, parent) {
  const previous = siblingBefore(parent, index);
  const head2 = siblingAfter(node, -1, true);
  if (parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody(node, index, parent) {
  const previous = siblingBefore(parent, index);
  const head2 = siblingAfter(node, -1);
  if (parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
var constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node, index, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node.tagName === "svg") {
    state.schema = svg;
  }
  const attributes = serializeAttributes(state, node.properties);
  const content = state.all(
    schema.space === "html" && node.tagName === "template" ? node.content : node
  );
  state.schema = schema;
  if (content) selfClosing = false;
  if (attributes || !omit || !opening(node, index, parent)) {
    parts.push("<", node.tagName, attributes ? " " + attributes : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attributes.charAt(attributes.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content);
  if (!selfClosing && (!omit || !closing(node, index, parent))) {
    parts.push("</" + node.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, properties) {
  const values = [];
  let index = -1;
  let key2;
  if (properties) {
    for (key2 in properties) {
      if (properties[key2] !== null && properties[key2] !== void 0) {
        const value = serializeAttribute(state, key2, properties[key2]);
        if (value) values.push(value);
      }
    }
  }
  while (++index < values.length) {
    const last = state.settings.tightAttributes ? values[index].charAt(values[index].length - 1) : void 0;
    if (index !== values.length - 1 && last !== '"' && last !== "'") {
      values[index] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find(state.schema, key2);
  const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x][y]
    })
  );
  if (value === true) return name;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value) return name;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x][y]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x][y],
        attribute: true
      })
    ) + quote;
  }
  return name + (result ? "=" + result : result);
}
var textEntitySubset = ["<", "&"];
function text(node, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node.value : stringifyEntities(
    node.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: textEntitySubset
    })
  );
}
function raw(node, index, parent, state) {
  return state.settings.allowDangerousHtml ? node.value : text(node, index, parent, state);
}
function root(node, _1, _2, state) {
  return state.all(node);
}
var handle = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root, text }
});
function invalid(node) {
  throw new Error("Expected node, not `" + node + "`");
}
function unknown(node_) {
  const node = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node.type + "`");
}
var emptyOptions = {};
var emptyCharacterReferences = {};
var emptyChildren = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one,
    all,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg : html$2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one(node, index, parent) {
  return handle(node, index, parent, this);
}
function all(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren;
  let index = -1;
  while (++index < children.length) {
    results[index] = this.one(children[index], index, parent);
  }
  return results.join("");
}
function codeToHtml(internal, code2, options) {
  var _a;
  const context = {
    meta: {},
    options,
    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
  };
  let result = toHtml(codeToHast(internal, code2, options, context));
  for (const transformer of getTransformers(options))
    result = ((_a = transformer.postprocess) == null ? void 0 : _a.call(context, result, options)) || result;
  return result;
}
async function main(init) {
  let wasmMemory;
  let buffer;
  const binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    binding.HEAPU8 = new Uint8Array(buf);
    binding.HEAPU32 = new Uint32Array(buf);
  }
  function _emscripten_get_now() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
  }
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  function getHeapMax() {
    return 2147483648;
  }
  function emscripten_realloc_buffer(size) {
    try {
      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch (e) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize)
      return false;
    const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = emscripten_realloc_buffer(newSize);
      if (replacement)
        return true;
    }
    return false;
  }
  const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
    const endIdx = idx + maxBytesToRead;
    let endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx))
      ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    let str = "";
    while (idx < endPtr) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      const u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) === 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      const u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) === 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        const ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
  }
  const asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: () => 0
  };
  async function createWasm() {
    const info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    const exports = await init(info);
    wasmMemory = exports.memory;
    updateGlobalBufferAndViews(wasmMemory.buffer);
    Object.assign(binding, exports);
    binding.UTF8ToString = UTF8ToString;
  }
  await createWasm();
  return binding;
}
var onigBinding = null;
var defaultDebugCall = false;
function throwLastOnigError(onigBinding2) {
  throw new ShikiError(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
var UtfString = class _UtfString {
  constructor(str) {
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16Value");
    __publicField(this, "utf8Value");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    const utf16Length = str.length;
    const utf8Length = _UtfString._utf8ByteLength(str);
    const computeIndicesMapping = utf8Length !== utf16Length;
    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    if (computeIndicesMapping)
      utf16OffsetToUtf8[utf16Length] = utf8Length;
    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    if (computeIndicesMapping)
      utf8OffsetToUtf16[utf8Length] = utf16Length;
    const utf8Value = new Uint8Array(utf8Length);
    let i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      const charCode = str.charCodeAt(i16);
      let codePoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i16 + 1 < utf16Length) {
          const nextCharCode = str.charCodeAt(i16 + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (computeIndicesMapping) {
        utf16OffsetToUtf8[i16] = i8;
        if (wasSurrogatePair)
          utf16OffsetToUtf8[i16 + 1] = i8;
        if (codePoint <= 127) {
          utf8OffsetToUtf16[i8 + 0] = i16;
        } else if (codePoint <= 2047) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
        } else if (codePoint <= 65535) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
        } else {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
          utf8OffsetToUtf16[i8 + 3] = i16;
        }
      }
      if (codePoint <= 127) {
        utf8Value[i8++] = codePoint;
      } else if (codePoint <= 2047) {
        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint <= 65535) {
        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else {
        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      }
      if (wasSurrogatePair)
        i16++;
    }
    this.utf16Length = utf16Length;
    this.utf8Length = utf8Length;
    this.utf16Value = str;
    this.utf8Value = utf8Value;
    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const charCode = str.charCodeAt(i);
      let codepoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i + 1 < len) {
          const nextCharCode = str.charCodeAt(i + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (codepoint <= 127)
        result += 1;
      else if (codepoint <= 2047)
        result += 2;
      else if (codepoint <= 65535)
        result += 3;
      else
        result += 4;
      if (wasSurrogatePair)
        i++;
    }
    return result;
  }
  createString(onigBinding2) {
    const result = onigBinding2.omalloc(this.utf8Length);
    onigBinding2.HEAPU8.set(this.utf8Value, result);
    return result;
  }
};
var _OnigString = class _OnigString2 {
  constructor(str) {
    __publicField(this, "id", ++_OnigString2.LAST_ID);
    __publicField(this, "_onigBinding");
    __publicField(this, "content");
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    __publicField(this, "ptr");
    if (!onigBinding)
      throw new ShikiError("Must invoke loadWasm first.");
    this._onigBinding = onigBinding;
    this.content = str;
    const utfString = new UtfString(str);
    this.utf16Length = utfString.utf16Length;
    this.utf8Length = utfString.utf8Length;
    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
    if (this.utf8Length < 1e4 && !_OnigString2._sharedPtrInUse) {
      if (!_OnigString2._sharedPtr)
        _OnigString2._sharedPtr = onigBinding.omalloc(1e4);
      _OnigString2._sharedPtrInUse = true;
      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString2._sharedPtr);
      this.ptr = _OnigString2._sharedPtr;
    } else {
      this.ptr = utfString.createString(onigBinding);
    }
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (this.utf8OffsetToUtf16) {
      if (utf8Offset < 0)
        return 0;
      if (utf8Offset > this.utf8Length)
        return this.utf16Length;
      return this.utf8OffsetToUtf16[utf8Offset];
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (this.utf16OffsetToUtf8) {
      if (utf16Offset < 0)
        return 0;
      if (utf16Offset > this.utf16Length)
        return this.utf8Length;
      return this.utf16OffsetToUtf8[utf16Offset];
    }
    return utf16Offset;
  }
  dispose() {
    if (this.ptr === _OnigString2._sharedPtr)
      _OnigString2._sharedPtrInUse = false;
    else
      this._onigBinding.ofree(this.ptr);
  }
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
__publicField(_OnigString, "_sharedPtrInUse", false);
var OnigString = _OnigString;
var OnigScanner = class {
  constructor(patterns) {
    __publicField(this, "_onigBinding");
    __publicField(this, "_ptr");
    if (!onigBinding)
      throw new ShikiError("Must invoke loadWasm first.");
    const strPtrsArr = [];
    const strLenArr = [];
    for (let i = 0, len = patterns.length; i < len; i++) {
      const utfString = new UtfString(patterns[i]);
      strPtrsArr[i] = utfString.createString(onigBinding);
      strLenArr[i] = utfString.utf8Length;
    }
    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
    const strLenPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
    for (let i = 0, len = patterns.length; i < len; i++)
      onigBinding.ofree(strPtrsArr[i]);
    onigBinding.ofree(strLenPtr);
    onigBinding.ofree(strPtrsPtr);
    if (scannerPtr === 0)
      throwLastOnigError(onigBinding);
    this._onigBinding = onigBinding;
    this._ptr = scannerPtr;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(string, startPosition, arg) {
    let debugCall = defaultDebugCall;
    let options = 0;
    if (typeof arg === "number") {
      if (arg & 8)
        debugCall = true;
      options = arg;
    } else if (typeof arg === "boolean") {
      debugCall = arg;
    }
    if (typeof string === "string") {
      string = new OnigString(string);
      const result = this._findNextMatchSync(string, startPosition, debugCall, options);
      string.dispose();
      return result;
    }
    return this._findNextMatchSync(string, startPosition, debugCall, options);
  }
  _findNextMatchSync(string, startPosition, debugCall, options) {
    const onigBinding2 = this._onigBinding;
    let resultPtr;
    if (debugCall)
      resultPtr = onigBinding2.findNextOnigScannerMatchDbg(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    else
      resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    if (resultPtr === 0) {
      return null;
    }
    const HEAPU32 = onigBinding2.HEAPU32;
    let offset = resultPtr / 4;
    const index = HEAPU32[offset++];
    const count = HEAPU32[offset++];
    const captureIndices = [];
    for (let i = 0; i < count; i++) {
      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      captureIndices[i] = {
        start: beg,
        end,
        length: end - beg
      };
    }
    return {
      index,
      captureIndices
    };
  }
};
function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
  return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
  var _a;
  return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && ((_a = Buffer.isBuffer) == null ? void 0 : _a.call(Buffer, data)) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
var initPromise;
function loadWasm(options) {
  if (initPromise)
    return initPromise;
  async function _load() {
    onigBinding = await main(async (info) => {
      let instance = options;
      instance = await instance;
      if (typeof instance === "function")
        instance = await instance(info);
      if (typeof instance === "function")
        instance = await instance(info);
      if (isInstantiatorOptionsObject(instance)) {
        instance = await instance.instantiator(info);
      } else if (isInstantiatorModule(instance)) {
        instance = await instance.default(info);
      } else {
        if (isDataOptionsObject(instance))
          instance = instance.data;
        if (isResponse(instance)) {
          if (typeof WebAssembly.instantiateStreaming === "function")
            instance = await _makeResponseStreamingLoader(instance)(info);
          else
            instance = await _makeResponseNonStreamingLoader(instance)(info);
        } else if (isArrayBuffer(instance)) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if (instance instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if ("default" in instance && instance.default instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance.default)(info);
        }
      }
      if ("instance" in instance)
        instance = instance.instance;
      if ("exports" in instance)
        instance = instance.exports;
      return instance;
    });
  }
  initPromise = _load();
  return initPromise;
}
function _makeArrayBufferLoader(data) {
  return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
  return async (importObject) => {
    const arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
}
function createOnigString(str) {
  return new OnigString(str);
}
function createOnigScanner(patterns) {
  return new OnigScanner(patterns);
}
var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
var RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
  var _a, _b, _c, _d, _e;
  if (rawTheme == null ? void 0 : rawTheme[RESOLVED_KEY])
    return rawTheme;
  const theme = {
    ...rawTheme
  };
  if (theme.tokenColors && !theme.settings) {
    theme.settings = theme.tokenColors;
    delete theme.tokenColors;
  }
  theme.type || (theme.type = "dark");
  theme.colorReplacements = { ...theme.colorReplacements };
  theme.settings || (theme.settings = []);
  let { bg, fg } = theme;
  if (!bg || !fg) {
    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;
    if ((_a = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _a.foreground)
      fg = globalSetting.settings.foreground;
    if ((_b = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _b.background)
      bg = globalSetting.settings.background;
    if (!fg && ((_c = theme == null ? void 0 : theme.colors) == null ? void 0 : _c["editor.foreground"]))
      fg = theme.colors["editor.foreground"];
    if (!bg && ((_d = theme == null ? void 0 : theme.colors) == null ? void 0 : _d["editor.background"]))
      bg = theme.colors["editor.background"];
    if (!fg)
      fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
    if (!bg)
      bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
    theme.fg = fg;
    theme.bg = bg;
  }
  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
    theme.settings.unshift({
      settings: {
        foreground: theme.fg,
        background: theme.bg
      }
    });
  }
  let replacementCount = 0;
  const replacementMap = /* @__PURE__ */ new Map();
  function getReplacementColor(value) {
    var _a2;
    if (replacementMap.has(value))
      return replacementMap.get(value);
    replacementCount += 1;
    const hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    if ((_a2 = theme.colorReplacements) == null ? void 0 : _a2[`#${hex}`])
      return getReplacementColor(value);
    replacementMap.set(value, hex);
    return hex;
  }
  theme.settings = theme.settings.map((setting) => {
    var _a2, _b2;
    const replaceFg = ((_a2 = setting.settings) == null ? void 0 : _a2.foreground) && !setting.settings.foreground.startsWith("#");
    const replaceBg = ((_b2 = setting.settings) == null ? void 0 : _b2.background) && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg)
      return setting;
    const clone2 = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      const replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground;
      clone2.settings.foreground = replacement;
    }
    if (replaceBg) {
      const replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background;
      clone2.settings.background = replacement;
    }
    return clone2;
  });
  for (const key2 of Object.keys(theme.colors || {})) {
    if (key2 === "editor.foreground" || key2 === "editor.background" || key2.startsWith("terminal.ansi")) {
      if (!((_e = theme.colors[key2]) == null ? void 0 : _e.startsWith("#"))) {
        const replacement = getReplacementColor(theme.colors[key2]);
        theme.colorReplacements[replacement] = theme.colors[key2];
        theme.colors[key2] = replacement;
      }
    }
  }
  Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: false,
    writable: false,
    value: true
  });
  return theme;
}
var Registry2 = class extends Registry$1 {
  constructor(_resolver, _themes, _langs, _alias = {}) {
    super(_resolver);
    __publicField(this, "_resolver");
    __publicField(this, "_themes");
    __publicField(this, "_langs");
    __publicField(this, "_alias");
    __publicField(this, "_resolvedThemes", /* @__PURE__ */ new Map());
    __publicField(this, "_resolvedGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_langMap", /* @__PURE__ */ new Map());
    __publicField(this, "_langGraph", /* @__PURE__ */ new Map());
    __publicField(this, "_textmateThemeCache", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_loadedThemesCache", null);
    __publicField(this, "_loadedLanguagesCache", null);
    this._resolver = _resolver;
    this._themes = _themes;
    this._langs = _langs;
    this._alias = _alias;
    _themes.forEach((t) => this.loadTheme(t));
    _langs.forEach((l) => this.loadLanguage(l));
  }
  getTheme(theme) {
    if (typeof theme === "string")
      return this._resolvedThemes.get(theme);
    else
      return this.loadTheme(theme);
  }
  loadTheme(theme) {
    const _theme = normalizeTheme(theme);
    if (_theme.name) {
      this._resolvedThemes.set(_theme.name, _theme);
      this._loadedThemesCache = null;
    }
    return _theme;
  }
  getLoadedThemes() {
    if (!this._loadedThemesCache)
      this._loadedThemesCache = [...this._resolvedThemes.keys()];
    return this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(theme) {
    let textmateTheme = this._textmateThemeCache.get(theme);
    if (!textmateTheme) {
      textmateTheme = Theme.createFromRawTheme(theme);
      this._textmateThemeCache.set(theme, textmateTheme);
    }
    this._syncRegistry.setTheme(textmateTheme);
  }
  getGrammar(name) {
    if (this._alias[name]) {
      const resolved = /* @__PURE__ */ new Set([name]);
      while (this._alias[name]) {
        name = this._alias[name];
        if (resolved.has(name))
          throw new ShikiError(`Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
        resolved.add(name);
      }
    }
    return this._resolvedGrammars.get(name);
  }
  async loadLanguage(lang) {
    var _a, _b, _c, _d;
    if (this.getGrammar(lang.name))
      return;
    const embeddedLazilyBy = new Set([...this._langMap.values()].filter((i) => {
      var _a2;
      return (_a2 = i.embeddedLangsLazy) == null ? void 0 : _a2.includes(lang.name);
    }));
    this._resolver.addLanguage(lang);
    const grammarConfig = {
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
    const g = await this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    g.name = lang.name;
    this._resolvedGrammars.set(lang.name, g);
    if (lang.aliases) {
      lang.aliases.forEach((alias) => {
        this._alias[alias] = lang.name;
      });
    }
    this._loadedLanguagesCache = null;
    if (embeddedLazilyBy.size) {
      for (const e of embeddedLazilyBy) {
        this._resolvedGrammars.delete(e.name);
        this._loadedLanguagesCache = null;
        (_b = (_a = this._syncRegistry) == null ? void 0 : _a._injectionGrammars) == null ? void 0 : _b.delete(e.scopeName);
        (_d = (_c = this._syncRegistry) == null ? void 0 : _c._grammars) == null ? void 0 : _d.delete(e.scopeName);
        await this.loadLanguage(this._langMap.get(e.name));
      }
    }
  }
  async init() {
    this._themes.map((t) => this.loadTheme(t));
    await this.loadLanguages(this._langs);
  }
  dispose() {
    super.dispose();
    this._resolvedThemes.clear();
    this._resolvedGrammars.clear();
    this._langMap.clear();
    this._langGraph.clear();
    this._loadedThemesCache = null;
  }
  async loadLanguages(langs) {
    for (const lang of langs)
      this.resolveEmbeddedLanguages(lang);
    const langsGraphArray = Array.from(this._langGraph.entries());
    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);
    if (missingLangs.length) {
      const dependents = langsGraphArray.filter(([_, lang]) => {
        var _a;
        return lang && ((_a = lang.embeddedLangs) == null ? void 0 : _a.some((l) => missingLangs.map(([name]) => name).includes(l)));
      }).filter((lang) => !missingLangs.includes(lang));
      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (const [_, lang] of langsGraphArray)
      this._resolver.addLanguage(lang);
    for (const [_, lang] of langsGraphArray)
      await this.loadLanguage(lang);
  }
  getLoadedLanguages() {
    if (!this._loadedLanguagesCache) {
      this._loadedLanguagesCache = [
        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
      ];
    }
    return this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(lang) {
    this._langMap.set(lang.name, lang);
    this._langGraph.set(lang.name, lang);
    if (lang.embeddedLangs) {
      for (const embeddedLang of lang.embeddedLangs)
        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
    }
  }
};
var Resolver = class {
  constructor(onigLibPromise, langs) {
    __publicField(this, "_langs", /* @__PURE__ */ new Map());
    __publicField(this, "_scopeToLang", /* @__PURE__ */ new Map());
    __publicField(this, "_injections", /* @__PURE__ */ new Map());
    __publicField(this, "_onigLibPromise");
    this._onigLibPromise = onigLibPromise;
    langs.forEach((i) => this.addLanguage(i));
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getLangRegistration(langIdOrAlias) {
    return this._langs.get(langIdOrAlias);
  }
  async loadGrammar(scopeName) {
    return this._scopeToLang.get(scopeName);
  }
  addLanguage(l) {
    this._langs.set(l.name, l);
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this._langs.set(a, l);
      });
    }
    this._scopeToLang.set(l.scopeName, l);
    if (l.injectTo) {
      l.injectTo.forEach((i) => {
        if (!this._injections.get(i))
          this._injections.set(i, []);
        this._injections.get(i).push(l.scopeName);
      });
    }
  }
  getInjections(scopeName) {
    const scopeParts = scopeName.split(".");
    let injections = [];
    for (let i = 1; i <= scopeParts.length; i++) {
      const subScopeName = scopeParts.slice(0, i).join(".");
      injections = [...injections, ...this._injections.get(subScopeName) || []];
    }
    return injections;
  }
};
var _defaultWasmLoader;
var instancesCount = 0;
async function createShikiInternal(options = {}) {
  instancesCount += 1;
  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)
    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let isDisposed = false;
  async function normalizeGetter(p2) {
    return Promise.resolve(typeof p2 === "function" ? p2() : p2).then((r) => r.default || r);
  }
  async function resolveLangs(langs2) {
    return Array.from(new Set((await Promise.all(langs2.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r])))).flat()));
  }
  const wasmLoader = options.loadWasm || _defaultWasmLoader;
  const [themes, langs] = await Promise.all([
    Promise.all((options.themes || []).map(normalizeGetter)).then((r) => r.map(normalizeTheme)),
    resolveLangs(options.langs || []),
    wasmLoader ? loadWasm(wasmLoader) : void 0
  ]);
  const resolver = new Resolver(Promise.resolve({
    createOnigScanner(patterns) {
      return createOnigScanner(patterns);
    },
    createOnigString(s) {
      return createOnigString(s);
    }
  }), langs);
  const _registry = new Registry2(resolver, themes, langs, options.langAlias);
  await _registry.init();
  let _lastTheme;
  function getLanguage(name) {
    ensureNotDisposed();
    const _lang = _registry.getGrammar(typeof name === "string" ? name : name.name);
    if (!_lang)
      throw new ShikiError(`Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  function getTheme(name) {
    if (name === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    ensureNotDisposed();
    const _theme = _registry.getTheme(name);
    if (!_theme)
      throw new ShikiError(`Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  function setTheme(name) {
    ensureNotDisposed();
    const theme = getTheme(name);
    if (_lastTheme !== name) {
      _registry.setTheme(theme);
      _lastTheme = name;
    }
    const colorMap = _registry.getColorMap();
    return {
      theme,
      colorMap
    };
  }
  function getLoadedThemes() {
    ensureNotDisposed();
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    ensureNotDisposed();
    return _registry.getLoadedLanguages();
  }
  async function loadLanguage(...langs2) {
    ensureNotDisposed();
    await _registry.loadLanguages(await resolveLangs(langs2));
  }
  async function loadTheme(...themes2) {
    ensureNotDisposed();
    await Promise.all(themes2.map(async (theme) => isSpecialTheme(theme) ? null : _registry.loadTheme(await normalizeGetter(theme))));
  }
  function ensureNotDisposed() {
    if (isDisposed)
      throw new ShikiError("Shiki instance has been disposed");
  }
  function dispose() {
    if (isDisposed)
      return;
    isDisposed = true;
    _registry.dispose();
    instancesCount -= 1;
  }
  return {
    setTheme,
    getTheme,
    getLanguage,
    getLoadedThemes,
    getLoadedLanguages,
    loadLanguage,
    loadTheme,
    dispose,
    [Symbol.dispose]: dispose
  };
}
async function createHighlighterCore(options = {}) {
  const internal = await createShikiInternal(options);
  return {
    getLastGrammarState: (code2, options2) => getLastGrammarState(internal, code2, options2),
    codeToTokensBase: (code2, options2) => codeToTokensBase(internal, code2, options2),
    codeToTokensWithThemes: (code2, options2) => codeToTokensWithThemes(internal, code2, options2),
    codeToTokens: (code2, options2) => codeToTokens(internal, code2, options2),
    codeToHast: (code2, options2) => codeToHast(internal, code2, options2),
    codeToHtml: (code2, options2) => codeToHtml(internal, code2, options2),
    ...internal,
    getInternalContext: () => internal
  };
}
function createdBundledHighlighter(bundledLanguages2, bundledThemes2, loadWasm2) {
  async function createHighlighter2(options) {
    function resolveLang(lang) {
      if (typeof lang === "string") {
        if (isSpecialLang(lang))
          return [];
        const bundle = bundledLanguages2[lang];
        if (!bundle)
          throw new ShikiError(`Language \`${lang}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return lang;
    }
    function resolveTheme(theme) {
      if (isSpecialTheme(theme))
        return "none";
      if (typeof theme === "string") {
        const bundle = bundledThemes2[theme];
        if (!bundle)
          throw new ShikiError(`Theme \`${theme}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return theme;
    }
    const _themes = (options.themes ?? []).map((i) => resolveTheme(i));
    const langs = (options.langs ?? []).map((i) => resolveLang(i));
    const core2 = await createHighlighterCore({
      ...options,
      themes: _themes,
      langs,
      loadWasm: loadWasm2
    });
    return {
      ...core2,
      loadLanguage(...langs2) {
        return core2.loadLanguage(...langs2.map(resolveLang));
      },
      loadTheme(...themes) {
        return core2.loadTheme(...themes.map(resolveTheme));
      }
    };
  }
  return createHighlighter2;
}
var bundledThemesInfo = [
  {
    "id": "andromeeda",
    "displayName": "Andromeeda",
    "type": "dark",
    "import": () => import("./andromeeda-RB6AXGED.js")
  },
  {
    "id": "aurora-x",
    "displayName": "Aurora X",
    "type": "dark",
    "import": () => import("./aurora-x-7TRCRYNW.js")
  },
  {
    "id": "ayu-dark",
    "displayName": "Ayu Dark",
    "type": "dark",
    "import": () => import("./ayu-dark-C62BFQPN.js")
  },
  {
    "id": "catppuccin-frappe",
    "displayName": "Catppuccin Frappé",
    "type": "dark",
    "import": () => import("./catppuccin-frappe-XITWYKCU.js")
  },
  {
    "id": "catppuccin-latte",
    "displayName": "Catppuccin Latte",
    "type": "light",
    "import": () => import("./catppuccin-latte-R2ZBADCI.js")
  },
  {
    "id": "catppuccin-macchiato",
    "displayName": "Catppuccin Macchiato",
    "type": "dark",
    "import": () => import("./catppuccin-macchiato-VGAFM67Q.js")
  },
  {
    "id": "catppuccin-mocha",
    "displayName": "Catppuccin Mocha",
    "type": "dark",
    "import": () => import("./catppuccin-mocha-LTOB3JYQ.js")
  },
  {
    "id": "dark-plus",
    "displayName": "Dark Plus",
    "type": "dark",
    "import": () => import("./dark-plus-ERV2UZMC.js")
  },
  {
    "id": "dracula",
    "displayName": "Dracula",
    "type": "dark",
    "import": () => import("./dracula-7DFIXSLE.js")
  },
  {
    "id": "dracula-soft",
    "displayName": "Dracula Soft",
    "type": "dark",
    "import": () => import("./dracula-soft-H5N4CXU3.js")
  },
  {
    "id": "github-dark",
    "displayName": "GitHub Dark",
    "type": "dark",
    "import": () => import("./github-dark-WSEEZYAP.js")
  },
  {
    "id": "github-dark-default",
    "displayName": "GitHub Dark Default",
    "type": "dark",
    "import": () => import("./github-dark-default-IGTDZD3D.js")
  },
  {
    "id": "github-dark-dimmed",
    "displayName": "GitHub Dark Dimmed",
    "type": "dark",
    "import": () => import("./github-dark-dimmed-J5VZMRUY.js")
  },
  {
    "id": "github-light",
    "displayName": "GitHub Light",
    "type": "light",
    "import": () => import("./github-light-FV4XSQRK.js")
  },
  {
    "id": "github-light-default",
    "displayName": "GitHub Light Default",
    "type": "light",
    "import": () => import("./github-light-default-KQOIGHQS.js")
  },
  {
    "id": "houston",
    "displayName": "Houston",
    "type": "dark",
    "import": () => import("./houston-75PC6SAN.js")
  },
  {
    "id": "laserwave",
    "displayName": "LaserWave",
    "type": "dark",
    "import": () => import("./laserwave-W2UJHNMR.js")
  },
  {
    "id": "light-plus",
    "displayName": "Light Plus",
    "type": "light",
    "import": () => import("./light-plus-2LD7XKAP.js")
  },
  {
    "id": "material-theme",
    "displayName": "Material Theme",
    "type": "dark",
    "import": () => import("./material-theme-33RIAQAT.js")
  },
  {
    "id": "material-theme-darker",
    "displayName": "Material Theme Darker",
    "type": "dark",
    "import": () => import("./material-theme-darker-J52IORBS.js")
  },
  {
    "id": "material-theme-lighter",
    "displayName": "Material Theme Lighter",
    "type": "light",
    "import": () => import("./material-theme-lighter-G6ST7DVI.js")
  },
  {
    "id": "material-theme-ocean",
    "displayName": "Material Theme Ocean",
    "type": "dark",
    "import": () => import("./material-theme-ocean-RU5FBIOD.js")
  },
  {
    "id": "material-theme-palenight",
    "displayName": "Material Theme Palenight",
    "type": "dark",
    "import": () => import("./material-theme-palenight-PT5AZLJ6.js")
  },
  {
    "id": "min-dark",
    "displayName": "Min Dark",
    "type": "dark",
    "import": () => import("./min-dark-Z2NYRFNB.js")
  },
  {
    "id": "min-light",
    "displayName": "Min Light",
    "type": "light",
    "import": () => import("./min-light-GPDXKXFR.js")
  },
  {
    "id": "monokai",
    "displayName": "Monokai",
    "type": "dark",
    "import": () => import("./monokai-OV3JRPGE.js")
  },
  {
    "id": "night-owl",
    "displayName": "Night Owl",
    "type": "dark",
    "import": () => import("./night-owl-EASCIT6I.js")
  },
  {
    "id": "nord",
    "displayName": "Nord",
    "type": "dark",
    "import": () => import("./nord-ZP643PIU.js")
  },
  {
    "id": "one-dark-pro",
    "displayName": "One Dark Pro",
    "type": "dark",
    "import": () => import("./one-dark-pro-HHQ3QD4J.js")
  },
  {
    "id": "one-light",
    "displayName": "One Light",
    "type": "light",
    "import": () => import("./one-light-XOP2MOIN.js")
  },
  {
    "id": "poimandres",
    "displayName": "Poimandres",
    "type": "dark",
    "import": () => import("./poimandres-ADBIDOQY.js")
  },
  {
    "id": "red",
    "displayName": "Red",
    "type": "dark",
    "import": () => import("./red-D5F5HDZ2.js")
  },
  {
    "id": "rose-pine",
    "displayName": "Rosé Pine",
    "type": "dark",
    "import": () => import("./rose-pine-LGDGYEPI.js")
  },
  {
    "id": "rose-pine-dawn",
    "displayName": "Rosé Pine Dawn",
    "type": "light",
    "import": () => import("./rose-pine-dawn-DJDOUXS7.js")
  },
  {
    "id": "rose-pine-moon",
    "displayName": "Rosé Pine Moon",
    "type": "dark",
    "import": () => import("./rose-pine-moon-UHUDFNV5.js")
  },
  {
    "id": "slack-dark",
    "displayName": "Slack Dark",
    "type": "dark",
    "import": () => import("./slack-dark-XTPLHT7C.js")
  },
  {
    "id": "slack-ochin",
    "displayName": "Slack Ochin",
    "type": "light",
    "import": () => import("./slack-ochin-JUVDFSSA.js")
  },
  {
    "id": "snazzy-light",
    "displayName": "Snazzy Light",
    "type": "light",
    "import": () => import("./snazzy-light-66PP7PON.js")
  },
  {
    "id": "solarized-dark",
    "displayName": "Solarized Dark",
    "type": "dark",
    "import": () => import("./solarized-dark-PHWGSPWW.js")
  },
  {
    "id": "solarized-light",
    "displayName": "Solarized Light",
    "type": "light",
    "import": () => import("./solarized-light-BFAILDZT.js")
  },
  {
    "id": "synthwave-84",
    "displayName": "Synthwave '84",
    "type": "dark",
    "import": () => import("./synthwave-84-TDWF23KE.js")
  },
  {
    "id": "tokyo-night",
    "displayName": "Tokyo Night",
    "type": "dark",
    "import": () => import("./tokyo-night-UKGCCIPP.js")
  },
  {
    "id": "vesper",
    "displayName": "Vesper",
    "type": "dark",
    "import": () => import("./vesper-37AUAQEO.js")
  },
  {
    "id": "vitesse-black",
    "displayName": "Vitesse Black",
    "type": "dark",
    "import": () => import("./vitesse-black-3ONIJ74B.js")
  },
  {
    "id": "vitesse-dark",
    "displayName": "Vitesse Dark",
    "type": "dark",
    "import": () => import("./vitesse-dark-6A3ZB3P3.js")
  },
  {
    "id": "vitesse-light",
    "displayName": "Vitesse Light",
    "type": "light",
    "import": () => import("./vitesse-light-636YLTR3.js")
  }
];
var bundledThemes = Object.fromEntries(bundledThemesInfo.map((i) => [i.id, i.import]));
var bundledLanguagesInfo = [
  {
    "id": "angular-html",
    "name": "Angular HTML",
    "import": () => import("./angular-html-BQZKM6U2.js").then((n) => n.e)
  },
  {
    "id": "angular-ts",
    "name": "Angular TypeScript",
    "import": () => import("./angular-ts-3TYVD5ER.js")
  },
  {
    "id": "astro",
    "name": "Astro",
    "import": () => import("./astro-X77MWBMT.js")
  },
  {
    "id": "blade",
    "name": "Blade",
    "import": () => import("./blade-K2OHIOIM.js")
  },
  {
    "id": "c",
    "name": "C",
    "import": () => import("./c-VMD2XWDC.js")
  },
  {
    "id": "coffee",
    "name": "CoffeeScript",
    "aliases": [
      "coffeescript"
    ],
    "import": () => import("./coffee-KGUKILDI.js")
  },
  {
    "id": "cpp",
    "name": "C++",
    "aliases": [
      "c++"
    ],
    "import": () => import("./cpp-2I3LDFM6.js")
  },
  {
    "id": "css",
    "name": "CSS",
    "import": () => import("./css-DUAO7B4M.js")
  },
  {
    "id": "edge",
    "name": "Edge",
    "import": () => import("./edge-DLPC42DZ.js")
  },
  {
    "id": "glsl",
    "name": "GLSL",
    "import": () => import("./glsl-5XJT2RK2.js")
  },
  {
    "id": "graphql",
    "name": "GraphQL",
    "aliases": [
      "gql"
    ],
    "import": () => import("./graphql-VLYQXH4Z.js")
  },
  {
    "id": "haml",
    "name": "Ruby Haml",
    "import": () => import("./haml-O2XACYKH.js")
  },
  {
    "id": "handlebars",
    "name": "Handlebars",
    "aliases": [
      "hbs"
    ],
    "import": () => import("./handlebars-6RKGVEE7.js")
  },
  {
    "id": "html",
    "name": "HTML",
    "import": () => import("./html-QTGFR7KF.js")
  },
  {
    "id": "html-derivative",
    "name": "HTML (Derivative)",
    "import": () => import("./html-derivative-TPH4HAQ2.js")
  },
  {
    "id": "http",
    "name": "HTTP",
    "import": () => import("./http-PW7F44KA.js")
  },
  {
    "id": "imba",
    "name": "Imba",
    "import": () => import("./imba-NHHSSFOX.js")
  },
  {
    "id": "java",
    "name": "Java",
    "import": () => import("./java-2CPLZS7E.js")
  },
  {
    "id": "javascript",
    "name": "JavaScript",
    "aliases": [
      "js"
    ],
    "import": () => import("./javascript-5LV25H7F.js")
  },
  {
    "id": "jinja",
    "name": "Jinja",
    "import": () => import("./jinja-TZ42XASM.js")
  },
  {
    "id": "jison",
    "name": "Jison",
    "import": () => import("./jison-GR4P56ZH.js")
  },
  {
    "id": "json",
    "name": "JSON",
    "import": () => import("./json-RY6GMLVB.js")
  },
  {
    "id": "json5",
    "name": "JSON5",
    "import": () => import("./json5-7RG6YCBF.js")
  },
  {
    "id": "jsonc",
    "name": "JSON with Comments",
    "import": () => import("./jsonc-3A4Z4BVO.js")
  },
  {
    "id": "jsonl",
    "name": "JSON Lines",
    "import": () => import("./jsonl-LB4IY6NX.js")
  },
  {
    "id": "jsx",
    "name": "JSX",
    "import": () => import("./jsx-LR4XSHAN.js")
  },
  {
    "id": "julia",
    "name": "Julia",
    "aliases": [
      "jl"
    ],
    "import": () => import("./julia-SRDUYLAB.js")
  },
  {
    "id": "less",
    "name": "Less",
    "import": () => import("./less-WAZBWIHX.js")
  },
  {
    "id": "lua",
    "name": "Lua",
    "import": () => import("./lua-YKNHLG7S.js")
  },
  {
    "id": "markdown",
    "name": "Markdown",
    "aliases": [
      "md"
    ],
    "import": () => import("./markdown-XO3KAMOO.js")
  },
  {
    "id": "marko",
    "name": "Marko",
    "import": () => import("./marko-EX4VK4PG.js")
  },
  {
    "id": "mdc",
    "name": "MDC",
    "import": () => import("./mdc-AZ32S7UX.js")
  },
  {
    "id": "mdx",
    "name": "MDX",
    "import": () => import("./mdx-3Y4UIEUG.js")
  },
  {
    "id": "php",
    "name": "PHP",
    "import": () => import("./php-XYZKH3CN.js")
  },
  {
    "id": "postcss",
    "name": "PostCSS",
    "import": () => import("./postcss-VK4INI7B.js")
  },
  {
    "id": "pug",
    "name": "Pug",
    "aliases": [
      "jade"
    ],
    "import": () => import("./pug-ZDC7UF4R.js")
  },
  {
    "id": "python",
    "name": "Python",
    "aliases": [
      "py"
    ],
    "import": () => import("./python-YDOEZMB3.js")
  },
  {
    "id": "r",
    "name": "R",
    "import": () => import("./r-A7IQGTY4.js")
  },
  {
    "id": "ruby",
    "name": "Ruby",
    "aliases": [
      "rb"
    ],
    "import": () => import("./ruby-S36KGO3Q.js")
  },
  {
    "id": "sass",
    "name": "Sass",
    "import": () => import("./sass-SP6KHTQW.js")
  },
  {
    "id": "scss",
    "name": "SCSS",
    "import": () => import("./scss-DK4BRVSL.js")
  },
  {
    "id": "shellscript",
    "name": "Shell",
    "aliases": [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    "import": () => import("./shellscript-DM3CKT34.js")
  },
  {
    "id": "sql",
    "name": "SQL",
    "import": () => import("./sql-U3JJ7MXZ.js")
  },
  {
    "id": "stylus",
    "name": "Stylus",
    "aliases": [
      "styl"
    ],
    "import": () => import("./stylus-IXDTIZUB.js")
  },
  {
    "id": "svelte",
    "name": "Svelte",
    "import": () => import("./svelte-PZUXSH47.js")
  },
  {
    "id": "toml",
    "name": "TOML",
    "import": () => import("./toml-PJH3R7RE.js")
  },
  {
    "id": "tsx",
    "name": "TSX",
    "import": () => import("./tsx-MQYN7SZQ.js")
  },
  {
    "id": "typescript",
    "name": "TypeScript",
    "aliases": [
      "ts"
    ],
    "import": () => import("./typescript-LTC3BR2J.js")
  },
  {
    "id": "vue",
    "name": "Vue",
    "import": () => import("./vue-4RM6XHWR.js")
  },
  {
    "id": "vue-html",
    "name": "Vue HTML",
    "import": () => import("./vue-html-YCYJ2R7H.js")
  },
  {
    "id": "wasm",
    "name": "WebAssembly",
    "import": () => import("./wasm2-EEYVDFI6.js")
  },
  {
    "id": "wgsl",
    "name": "WGSL",
    "import": () => import("./wgsl-S3DNUB4J.js")
  },
  {
    "id": "xml",
    "name": "XML",
    "import": () => import("./xml-63FCND2W.js")
  },
  {
    "id": "yaml",
    "name": "YAML",
    "aliases": [
      "yml"
    ],
    "import": () => import("./yaml-KA3KFT5Z.js")
  }
];
var bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i) => [i.id, i.import]));
var bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i) => {
  var _a;
  return ((_a = i.aliases) == null ? void 0 : _a.map((a) => [a, i.import])) || [];
}));
var bundledLanguages = {
  ...bundledLanguagesBase,
  ...bundledLanguagesAlias
};
var createHighlighter = createdBundledHighlighter(
  bundledLanguages,
  bundledThemes,
  getWasmInlined
);
var useHasListener = (eventName) => {
  var _a;
  const vm = getCurrentInstance();
  const props = (_a = vm.vnode) == null ? void 0 : _a.props;
  return props && toHandlerKey(eventName) in props;
};
var _hoisted_1$b = { class: "code-preview-wrapper" };
var _hoisted_2$6 = { class: "code-preview" };
var _hoisted_3$6 = ["innerHTML"];
var _sfc_main$l = defineComponent({
  __name: "CodeView",
  props: {
    code: {},
    delay: { default: 500 }
  },
  emits: ["update:code"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const html2 = ref();
    let highlighter = ref();
    onMounted(async () => {
      highlighter.value = await createHighlighter({
        themes: ["material-theme-lighter"],
        langs: ["vue"]
      });
    });
    watchEffect(async () => {
      if (!highlighter.value) return;
      html2.value = await highlighter.value.codeToHtml(localCode.value, {
        lang: "html",
        theme: "material-theme-lighter"
      });
    });
    const isEditMode = useHasListener("update:code");
    const localCode = ref(props.code);
    watch(() => props.code, () => {
      if (props.code !== localCode.value) {
        localCode.value = props.code;
      }
    });
    const autoSave = ref(true);
    const saveCode = (v) => emit("update:code", v);
    let timeout;
    const vModelCode = computed({
      get() {
        return localCode.value;
      },
      set(v) {
        localCode.value = v;
        if (!autoSave.value) {
          return;
        }
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          saveCode(v);
        }, props.delay);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createBaseVNode("div", _hoisted_2$6, [
          createBaseVNode("span", {
            innerHTML: html2.value,
            class: "code-preview__view"
          }, null, 8, _hoisted_3$6),
          unref(isEditMode) ? withDirectives((openBlock(), createElementBlock("textarea", {
            key: 0,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vModelCode.value = $event),
            class: "code-preview__textarea shiki material-theme-lighter"
          }, null, 512)), [
            [vModelText, vModelCode.value]
          ]) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
var _hoisted_1$a = { class: "va-devtools-source-code" };
var _hoisted_2$5 = { class: "va-devtools-source-code__toolbar" };
var _hoisted_3$5 = { class: "va-devtools-source-code__file-name" };
var _hoisted_4$2 = { class: "va-devtools-source-code__code" };
var _sfc_main$k = defineComponent({
  __name: "ComponentSource",
  setup(__props) {
    const { source } = useComponent();
    const isLoading = ref(false);
    const newSource = ref("");
    watch(source.content, (newNewSource) => {
      newSource.value = newNewSource ?? "";
    }, { immediate: true });
    const save = () => {
      if (!source.content.value) return;
      try {
        isLoading.value = true;
        source.update(newSource.value);
      } finally {
        isLoading.value = false;
      }
    };
    return (_ctx, _cache) => {
      const _component_VaButton = resolveComponent("VaButton");
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$a, [
          createBaseVNode("div", _hoisted_2$5, [
            createBaseVNode("div", _hoisted_3$5, toDisplayString(unref(source).fileName), 1),
            createVNode(_component_VaButton, {
              preset: "secondary",
              icon: "save",
              loading: isLoading.value,
              onClick: save
            }, null, 8, ["loading"])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$2, [
          unref(source) !== null ? (openBlock(), createBlock(_sfc_main$l, {
            key: 0,
            code: newSource.value,
            "onUpdate:code": _cache[0] || (_cache[0] = ($event) => newSource.value = $event)
          }, null, 8, ["code"])) : createCommentVNode("", true)
        ])
      ], 64);
    };
  }
});
var ComponentSource = _export_sfc(_sfc_main$k, [["__scopeId", "data-v-b5b804cb"]]);
var _sfc_main$j = defineComponent({
  __name: "ComponentFile",
  props: {
    nodes: {}
  },
  setup(__props) {
    const { sameNodeItems, selectedAppTreeItem: selectedAppTreeItem2, selectAppTreeItem } = useAppTree();
    return (_ctx, _cache) => {
      const _component_VaButton = resolveComponent("VaButton");
      const _component_VaSelect = resolveComponent("VaSelect");
      return _ctx.$props.nodes.length < 3 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.$props.nodes, (item, index) => {
        return openBlock(), createElementBlock(Fragment, null, [
          createVNode(_component_VaButton, {
            preset: "secondary",
            color: item === unref(selectedAppTreeItem2) ? "primary" : "secondary",
            onClick: ($event) => unref(selectAppTreeItem)(item)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item.name), 1)
            ]),
            _: 2
          }, 1032, ["color", "onClick"]),
          index < unref(sameNodeItems).length - 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode("/")
          ], 64)) : createCommentVNode("", true)
        ], 64);
      }), 256)) : (openBlock(), createBlock(_component_VaSelect, {
        key: 1,
        options: _ctx.$props.nodes,
        "text-by": "name",
        "model-value": unref(selectedAppTreeItem2),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (item) => unref(selectAppTreeItem)(item))
      }, null, 8, ["options", "model-value"]));
    };
  }
});
var _hoisted_1$9 = { class: "va-devtools-flex-editor" };
var _sfc_main$i = defineComponent({
  __name: "FlexEditor",
  props: {
    state: {}
  },
  emits: ["update:state"],
  setup(__props, { emit: __emit }) {
    const horizontalOptions = [
      { icon: "align_horizontal_left", value: "left" },
      { icon: "align_horizontal_center", value: "center" },
      { icon: "align_horizontal_right", value: "right" }
    ];
    const verticalOptions = [
      { icon: "align_vertical_top", value: "top" },
      { icon: "align_vertical_center", value: "center" },
      { icon: "align_vertical_bottom", value: "bottom" }
    ];
    const directionOptions = [
      { icon: "arrow_forward", value: "horizontal" },
      { icon: "arrow_downward", value: "vertical" }
    ];
    const humanToFlex = (humanState) => {
      const vars = {
        horizontal: { horizontal: "justify-content", vertical: "align-items" },
        vertical: { horizontal: "align-items", vertical: "justify-content" }
      };
      return {
        display: "flex",
        "flex-direction": humanState.direction === "horizontal" ? "row" : "column",
        [vars[humanState.direction].horizontal]: humanState.horizontal === "left" ? "flex-start" : humanState.horizontal === "center" ? "center" : "flex-end",
        [vars[humanState.direction].vertical]: humanState.vertical === "top" ? "flex-start" : humanState.vertical === "center" ? "center" : "flex-end"
      };
    };
    const flexToHuman = (flexState) => {
      const vars = {
        row: { justifyContent: "horizontal", alignItems: "vertical" },
        column: { justifyContent: "vertical", alignItems: "horizontal" }
      };
      return {
        direction: flexState["flex-direction"] === "row" ? "horizontal" : "vertical",
        [vars[flexState["flex-direction"]].justifyContent]: flexState["justify-content"] === "flex-start" ? "left" : flexState["justify-content"] === "center" ? "center" : "right",
        [vars[flexState["flex-direction"]].alignItems]: flexState["align-items"] === "flex-start" ? "top" : flexState["align-items"] === "center" ? "center" : "bottom"
      };
    };
    const props = __props;
    const state = ref(flexToHuman(props.state));
    const emit = __emit;
    watch(state, () => {
      emit("update:state", humanToFlex(state.value));
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createVNode(unref(VaButtonToggle), {
          modelValue: state.value.horizontal,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => state.value.horizontal = $event),
          options: horizontalOptions,
          preset: "primary"
        }, null, 8, ["modelValue"]),
        createVNode(unref(VaButtonToggle), {
          modelValue: state.value.vertical,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.value.vertical = $event),
          options: verticalOptions,
          preset: "primary"
        }, null, 8, ["modelValue"]),
        createVNode(unref(VaButtonToggle), {
          modelValue: state.value.direction,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => state.value.direction = $event),
          options: directionOptions,
          preset: "primary"
        }, null, 8, ["modelValue"])
      ]);
    };
  }
});
var FlexEditor = _export_sfc(_sfc_main$i, [["__scopeId", "data-v-87ddd91c"]]);
var _withScopeId$2 = (n) => (pushScopeId("data-v-dbda30fa"), n = n(), popScopeId(), n);
var _hoisted_1$8 = {
  key: 0,
  class: "va-devtools-layout-editor--no-flex-container"
};
var _hoisted_2$4 = _withScopeId$2(() => createBaseVNode("p", null, "Layout settings are only available for flex containers for now.", -1));
var _hoisted_3$4 = { key: 1 };
var _sfc_main$h = defineComponent({
  __name: "LayoutEditor",
  setup(__props) {
    const { options } = useComponent();
    const onFlexEditorUpdate = (state) => {
      const newStyle = {
        ...options.style.value,
        ...state
      };
      options.style.value = newStyle;
    };
    const isFlexContainer = computed(() => {
      return options.style.value.display === "flex";
    });
    const makeFlexContainer = () => {
      options.style.value = {
        display: "flex",
        "flex-direction": "column",
        "justify-content": "flex-start",
        "align-items": "flex-start"
      };
    };
    const flexStyles = computed(() => {
      return {
        display: options.style.value.display,
        "flex-direction": options.style.value["flex-direction"],
        "justify-content": options.style.value["justify-content"],
        "align-items": options.style.value["align-items"]
      };
    });
    return (_ctx, _cache) => {
      return !isFlexContainer.value ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
        _hoisted_2$4,
        createVNode(unref(VaButton), {
          preset: "secondary",
          onClick: makeFlexContainer
        }, {
          default: withCtx(() => [
            createTextVNode("Make flex container")
          ]),
          _: 1
        })
      ])) : (openBlock(), createElementBlock("div", _hoisted_3$4, [
        createVNode(FlexEditor, {
          state: flexStyles.value,
          "onUpdate:state": onFlexEditorUpdate
        }, null, 8, ["state"])
      ]));
    };
  }
});
var LayoutEditor = _export_sfc(_sfc_main$h, [["__scopeId", "data-v-dbda30fa"]]);
var _hoisted_1$7 = createBaseVNode("p", { class: "va-title mb-2" }, "Flex layout", -1);
var _sfc_main$g = defineComponent({
  __name: "LayoutEditor",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        _hoisted_1$7,
        createVNode(LayoutEditor)
      ]);
    };
  }
});
var _hoisted_1$6 = { class: "c-component-view" };
var _hoisted_2$3 = { class: "c-component-view__toolbar" };
var _hoisted_3$3 = { key: 0 };
var _hoisted_4$1 = { class: "c-component-view__content" };
var _hoisted_5$1 = { class: "c-component-view__tabs-content" };
var _sfc_main$f = defineComponent({
  __name: "ComponentView",
  setup(__props) {
    const {
      name,
      source,
      code: code2,
      options
    } = useComponent();
    const { sameNodeItems, selectedAppTreeItem: selectedAppTreeItem2, selectAppTreeItem } = useAppTree();
    const tabs = computed(() => {
      return [
        { name: "Props", disabled: Object.keys(options.props.value).length === 0 },
        { name: "Slots", disabled: options.slots.value.length === 0 },
        { name: "Layout", disabled: false },
        { name: "Source Code", disabled: source.value === null }
      ];
    });
    const tab = ref(0);
    watch(code2.isParsed, (isParsed) => {
      if (tabs.value[tab.value].disabled && isParsed) {
        tab.value = tabs.value.findIndex((tab2) => !tab2.disabled);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$3, [
          unref(sameNodeItems).length === 1 ? (openBlock(), createElementBlock("h1", _hoisted_3$3, toDisplayString(unref(name)), 1)) : (openBlock(), createBlock(_sfc_main$j, {
            key: 1,
            nodes: unref(sameNodeItems)
          }, null, 8, ["nodes"])),
          createVNode(unref(_sfc_main)),
          createVNode(unref(VaButton), {
            icon: "open_in_new",
            onClick: unref(source).openInVSCode,
            preset: "primary",
            title: "Open in VSCode"
          }, null, 8, ["onClick"])
        ]),
        createBaseVNode("div", _hoisted_4$1, [
          createVNode(unref(VaTabs), {
            modelValue: tab.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
            class: "c-component-view__tabs"
          }, {
            tabs: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(tabs.value, (tab2) => {
                return openBlock(), createBlock(unref(VaTab), {
                  disabled: tab2.disabled
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(tab2.name), 1)
                  ]),
                  _: 2
                }, 1032, ["disabled"]);
              }), 256))
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createBaseVNode("div", _hoisted_5$1, [
            tab.value === 0 ? (openBlock(), createBlock(_sfc_main$n, { key: 0 })) : tab.value === 1 ? (openBlock(), createBlock(ComponentSlots, { key: 1 })) : tab.value === 2 ? (openBlock(), createBlock(_sfc_main$g, { key: 2 })) : tab.value === 3 ? (openBlock(), createBlock(ComponentSource, { key: 3 })) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});
var ComponentView = _export_sfc(_sfc_main$f, [["__scopeId", "data-v-68d86a66"]]);
var useWindowSize = () => {
  const size = reactive({ width: window.innerWidth, height: window.innerHeight });
  const updateSize = () => {
    size.width = window.innerWidth;
    size.height = window.innerHeight;
  };
  onMounted(() => {
    window.addEventListener("resize", updateSize);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("resize", updateSize);
  });
  return size;
};
var useElementRect = (el) => {
  const rect = ref();
  const resizeObserver = new ResizeObserver(([size]) => {
    rect.value = size.contentRect;
  });
  const setRect = (el2) => {
    if (el2) {
      rect.value = el2.getBoundingClientRect();
    }
  };
  window.addEventListener("resize", () => {
    setRect(el.value);
  });
  watchEffect(() => {
    setRect(el.value);
    if (el.value) {
      resizeObserver.observe(el.value);
    } else {
      resizeObserver.disconnect();
    }
  });
  return rect;
};
var _hoisted_1$5 = { class: "draggable-window-content" };
var PADDING = 8;
var _sfc_main$e = defineComponent({
  __name: "DraggableWindow",
  props: {
    defaultPosition: {},
    offsetY: {},
    offsetX: {}
  },
  setup(__props) {
    const box = ref();
    const windowSize = useWindowSize();
    const boxSize = useElementRect(box);
    const props = __props;
    const top = ref(0);
    const left = ref(0);
    const safeTop = computed(() => {
      var _a;
      if (top.value < PADDING) {
        return PADDING;
      }
      const offset = props.offsetY ?? 0;
      const topValue = top.value + offset;
      const height = (((_a = boxSize.value) == null ? void 0 : _a.height) ?? 0) + PADDING;
      if (topValue + height > windowSize.height) {
        return windowSize.height - height;
      }
      if (topValue < PADDING) {
        return PADDING;
      }
      return topValue;
    });
    const safeLeft = computed(() => {
      var _a, _b;
      let v = left.value;
      if (props.defaultPosition.endsWith("center")) {
        v = v - (((_a = boxSize.value) == null ? void 0 : _a.width) ?? 0) / 2;
      }
      const offset = props.offsetX ?? 0;
      v += offset;
      if (v < PADDING) {
        return PADDING;
      }
      const width = (((_b = boxSize.value) == null ? void 0 : _b.width) ?? 0) + PADDING;
      if (v + width > windowSize.width) {
        return windowSize.width - width;
      }
      return v;
    });
    const updateLeftAndTop = () => {
      const positions = {
        "top-left": { top: PADDING, left: PADDING },
        "top-right": { top: PADDING, left: windowSize.width },
        "bottom-center": { top: windowSize.height, left: windowSize.width / 2 },
        "bottom-left": { top: windowSize.height, left: PADDING }
      };
      top.value = positions[props.defaultPosition].top;
      left.value = positions[props.defaultPosition].left;
    };
    onMounted(() => {
      updateLeftAndTop();
    });
    useEvent("resize", () => {
      updateLeftAndTop();
    }, { capture: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "box",
        ref: box,
        class: "draggable-window",
        style: normalizeStyle({ top: `${safeTop.value}px`, left: `${safeLeft.value}px` })
      }, [
        createBaseVNode("div", _hoisted_1$5, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});
var _hoisted_1$4 = { key: 0 };
var _hoisted_2$2 = {
  key: 1,
  class: "app-tree-item"
};
var _hoisted_3$2 = {
  key: 0,
  class: "app-tree-item__children"
};
var _sfc_main$d = defineComponent({
  ...{
    name: "AppTreeItem"
  },
  __name: "AppTreeItem",
  props: {
    item: {}
  },
  setup(__props) {
    const props = __props;
    const { selectAppTreeItem, selectedAppTreeItem: selectedAppTreeItem2 } = useAppTree();
    const setTargetElement = () => {
      if ("text" in props.item) {
        return;
      }
      if (!props.item.el) {
        throw new Error("Element is not found");
      }
      selectAppTreeItem(props.item);
    };
    const isElementSelected = computed(() => {
      return selectedAppTreeItem2.value === props.item;
    });
    return (_ctx, _cache) => {
      const _component_AppTreeItem = resolveComponent("AppTreeItem", true);
      return "text" in props.item ? (openBlock(), createElementBlock("div", _hoisted_1$4)) : (openBlock(), createElementBlock("div", _hoisted_2$2, [
        createVNode(unref(VaButton), {
          class: normalizeClass(["app-tree-item__button", {
            "app-tree-item__button--selected": isElementSelected.value
          }]),
          preset: "secondary",
          color: isElementSelected.value ? "primary" : "secondary",
          onClick: setTargetElement
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(props.item.name) + " ", 1),
            props.item.repeated ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" (repeated) ")
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["color", "class"]),
        "children" in props.item ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
          props.item.children ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(props.item.children, (node) => {
            return openBlock(), createBlock(_component_AppTreeItem, { item: node }, null, 8, ["item"]);
          }), 256)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]));
    };
  }
});
var AppTreeItemComponent = _export_sfc(_sfc_main$d, [["__scopeId", "data-v-81da84db"]]);
var _hoisted_1$3 = {
  key: 0,
  class: "va-devtools-app-tree"
};
var _hoisted_2$1 = {
  key: 0,
  class: "va-devtools-app-tree__items"
};
var _hoisted_3$1 = { class: "va-devtools-app-tree__items" };
var _sfc_main$c = defineComponent({
  __name: "AppTree",
  setup(__props) {
    const { appTree: appTree2 } = useAppTree();
    const filter = ref("");
    const findTree = (query) => {
      if (!appTree2.value) return;
      const items = [];
      const find2 = (nodes) => {
        nodes.forEach((node) => {
          if ("text" in node) {
            return;
          }
          if (node.name.toLowerCase().includes(query.toLowerCase())) {
            items.push({
              ...node,
              children: []
            });
          }
          if (node.children) {
            find2(node.children);
          }
        });
      };
      find2(appTree2.value);
      return items;
    };
    const foundItems = computed(() => {
      return findTree(filter.value);
    });
    return (_ctx, _cache) => {
      return unref(appTree2) ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
        createVNode(unref(VaInput), {
          modelValue: filter.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filter.value = $event),
          "inner-label": "",
          style: { "width": "100%" },
          placeholder: "Search"
        }, {
          prependInner: withCtx(() => [
            createVNode(unref(VaIcon), { name: "search" })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        filter.value.length <= 0 ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(appTree2), (node) => {
            return openBlock(), createElementBlock("div", null, [
              createVNode(AppTreeItemComponent, { item: node }, null, 8, ["item"])
            ]);
          }), 256))
        ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(foundItems.value, (node) => {
          return openBlock(), createElementBlock("div", _hoisted_3$1, [
            createVNode(AppTreeItemComponent, { item: node }, null, 8, ["item"])
          ]);
        }), 256))
      ])) : createCommentVNode("", true);
    };
  }
});
var AppTree = _export_sfc(_sfc_main$c, [["__scopeId", "data-v-c3d9e271"]]);
var _sfc_main$b = defineComponent({
  __name: "ComponentSelectItem",
  props: {
    code: {},
    title: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaCardTitle = resolveComponent("VaCardTitle");
      const _component_VaCardContent = resolveComponent("VaCardContent");
      const _component_VaCard = resolveComponent("VaCard");
      return openBlock(), createBlock(_component_VaCard, {
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("select", _ctx.$props.code)),
        outlined: "",
        class: "va-devtools-component-select-item"
      }, {
        default: withCtx(() => [
          createVNode(_component_VaCardTitle, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ]),
            _: 1
          }),
          createVNode(_component_VaCardContent, {
            onClick: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"]))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 3
          })
        ]),
        _: 3
      });
    };
  }
});
var ComponentSelectItem = _export_sfc(_sfc_main$b, [["__scopeId", "data-v-e5e09e9d"]]);
var code$6 = `
<VaButton>
  Button
</VaButton>
  `;
var _sfc_main$a = defineComponent({
  __name: "Button",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaButton = resolveComponent("VaButton");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Button",
        code: code$6
      }, {
        default: withCtx(() => [
          createVNode(_component_VaButton, null, {
            default: withCtx(() => [
              createTextVNode(" Button ")
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
});
var code$5 = `
<VaButtonGroup>
  <VaButton>Button 1</VaButton>
  <VaButton>Button 2</VaButton>
  <VaButton>Button 3</VaButton>
</VaButtonGroup>
  `;
var _sfc_main$9 = defineComponent({
  __name: "ButtonGroup",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaButton = resolveComponent("VaButton");
      const _component_VaButtonGroup = resolveComponent("VaButtonGroup");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Button Group",
        code: code$5
      }, {
        default: withCtx(() => [
          createVNode(_component_VaButtonGroup, null, {
            default: withCtx(() => [
              createVNode(_component_VaButton, null, {
                default: withCtx(() => [
                  createTextVNode("Button 1")
                ]),
                _: 1
              }),
              createVNode(_component_VaButton, null, {
                default: withCtx(() => [
                  createTextVNode("Button 2")
                ]),
                _: 1
              }),
              createVNode(_component_VaButton, null, {
                default: withCtx(() => [
                  createTextVNode("Button 3")
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
});
var code$4 = `
<VaButtonToggle
  :options="[
    { value: '1', label: 'Option 1' },
    { value: '2', label: 'Option 2' },
    { value: '3', label: 'Option 3' },
  ]"
/>
  `;
var _sfc_main$8 = defineComponent({
  __name: "ButtonToggle",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaButtonToggle = resolveComponent("VaButtonToggle");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Button Group",
        code: code$4
      }, {
        default: withCtx(() => [
          createVNode(_component_VaButtonToggle, { options: [
            { value: "1", label: "Option 1" },
            { value: "2", label: "Option 2" },
            { value: "3", label: "Option 3" }
          ] })
        ]),
        _: 1
      });
    };
  }
});
var code$3 = `
<VaDateInput placeholder="Chose date" />
  `;
var _sfc_main$7 = defineComponent({
  __name: "DateInput",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaDateInput = resolveComponent("VaDateInput");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Date Input",
        code: code$3
      }, {
        default: withCtx(() => [
          createVNode(_component_VaDateInput, { placeholder: "Chose date" })
        ]),
        _: 1
      });
    };
  }
});
var code$2 = `
<VaInput placeholder="Enter text" />
  `;
var _sfc_main$6 = defineComponent({
  __name: "Input",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaInput = resolveComponent("VaInput");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Input",
        code: code$2
      }, {
        default: withCtx(() => [
          createVNode(_component_VaInput, { placeholder: "Enter text" })
        ]),
        _: 1
      });
    };
  }
});
var code$1 = `
<VaTimeInput placeholder="Chose date" />
  `;
var _sfc_main$5 = defineComponent({
  __name: "TimeInput",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_VaTimeInput = resolveComponent("VaTimeInput");
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Time Input",
        code: code$1
      }, {
        default: withCtx(() => [
          createVNode(_component_VaTimeInput, { placeholder: "Chose time" })
        ]),
        _: 1
      });
    };
  }
});
var _withScopeId$1 = (n) => (pushScopeId("data-v-00ae6796"), n = n(), popScopeId(), n);
var _hoisted_1$2 = _withScopeId$1(() => createBaseVNode("div", { class: "div" }, null, -1));
var code = `
<div>

</div>
  `;
var _sfc_main$4 = defineComponent({
  __name: "BasicDiv",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(ComponentSelectItem, {
        title: "Div",
        code
      }, {
        default: withCtx(() => [
          _hoisted_1$2
        ]),
        _: 1
      });
    };
  }
});
var BasicDiv = _export_sfc(_sfc_main$4, [["__scopeId", "data-v-00ae6796"]]);
var _withScopeId = (n) => (pushScopeId("data-v-52a5d047"), n = n(), popScopeId(), n);
var _hoisted_1$1 = { class: "va-devtools-component-select" };
var _hoisted_2 = { class: "va-devtools-component-select__components" };
var _hoisted_3 = _withScopeId(() => createBaseVNode("h2", null, "Basic", -1));
var _hoisted_4 = { class: "va-devtools-component-select__components-list" };
var _hoisted_5 = _withScopeId(() => createBaseVNode("h2", null, "Buttons", -1));
var _hoisted_6 = { class: "va-devtools-component-select__components-list" };
var _hoisted_7 = _withScopeId(() => createBaseVNode("h2", null, "Inputs", -1));
var _hoisted_8 = { class: "va-devtools-component-select__components-list" };
var _sfc_main$3 = defineComponent({
  __name: "ComponentSelect",
  emits: ["componentAdded"],
  setup(__props, { emit: __emit }) {
    const { source, code: code2 } = useComponent();
    const { refresh } = useAppTree();
    const addComponent = async (childCode) => {
      await source.update(code2.appendChild(childCode.trim()));
      setTimeout(() => {
        refresh();
      }, 300);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2, [
          _hoisted_3,
          createBaseVNode("div", _hoisted_4, [
            createVNode(BasicDiv, { onSelect: addComponent })
          ]),
          _hoisted_5,
          createBaseVNode("div", _hoisted_6, [
            createVNode(_sfc_main$a, { onSelect: addComponent }),
            createVNode(_sfc_main$9, { onSelect: addComponent }),
            createVNode(_sfc_main$8, { onSelect: addComponent })
          ]),
          _hoisted_7,
          createBaseVNode("div", _hoisted_8, [
            createVNode(_sfc_main$6, { onSelect: addComponent }),
            createVNode(_sfc_main$7, { onSelect: addComponent }),
            createVNode(_sfc_main$5, { onSelect: addComponent })
          ])
        ])
      ]);
    };
  }
});
var ComponentSelect = _export_sfc(_sfc_main$3, [["__scopeId", "data-v-52a5d047"]]);
var _sfc_main$2 = defineComponent({
  __name: "History",
  setup(__props) {
    const { source, uid } = useComponent();
    const history = ref([]);
    let watchIgnore = false;
    watch([source.content, uid], ([newSource, newUid], [oldSource, oldUid]) => {
      if (watchIgnore) {
        watchIgnore = false;
        return;
      }
      if (newUid !== oldUid) {
        history.value.push("targetChange");
        index.value += 1;
        return;
      }
      if (history.value[history.value.length - 1] === "targetChange") {
        history.value.pop();
        index.value -= 1;
        return;
      }
      if (newSource !== oldSource && newUid === oldUid && oldSource !== null && newSource !== null && newUid) {
        history.value = history.value.slice(0, index.value);
        const lastItem = history.value[history.value.length - 1];
        if (typeof lastItem === "object" && lastItem.newSource.trim() === newSource.trim()) {
          return;
        }
        index.value += 1;
        history.value.push({
          newSource,
          oldSource,
          minfiedPath: newUid
        });
      }
    });
    const index = ref(0);
    const current = computed(() => {
      return history.value[index.value - 1];
    });
    const undo = async () => {
      if (index.value > 0) {
        if (current.value === "targetChange") {
          return;
        }
        await setNodeSource(current.value.minfiedPath, current.value.oldSource);
        watchIgnore = true;
        await source.refresh();
        index.value--;
      }
    };
    const redo = async () => {
      if (index.value < history.value.length) {
        if (current.value === "targetChange") {
          return;
        }
        index.value++;
        await setNodeSource(current.value.minfiedPath, current.value.newSource);
        watchIgnore = true;
        await source.refresh();
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createVNode(unref(VaButton), {
          icon: "undo",
          onClick: undo,
          preset: "secondary",
          disabled: index.value <= 0
        }, null, 8, ["disabled"]),
        createVNode(unref(VaButton), {
          icon: "redo",
          onClick: redo,
          preset: "secondary",
          disabled: index.value >= history.value.length
        }, null, 8, ["disabled"])
      ]);
    };
  }
});
var _hoisted_1 = { class: "va-devtools-toolbar" };
var _sfc_main$1 = defineComponent({
  __name: "AppToolbar",
  setup(__props) {
    const { source } = useComponent();
    const isLoading = ref(false);
    const onSave = async () => {
      isLoading.value = true;
      await source.update(source.value);
      isLoading.value = false;
    };
    const removeComponent = async () => {
      try {
        isLoading.value = true;
        await source.remove();
      } finally {
        isLoading.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(_sfc_main$2),
        createVNode(unref(VaButton), {
          icon: "save",
          preset: "secondary",
          onClick: onSave,
          loading: isLoading.value
        }, null, 8, ["loading"]),
        createVNode(unref(VaDivider), { vertical: "" }),
        createVNode(unref(VaDropdown), {
          "close-on-content-click": false,
          "keep-anchor-width": false,
          offset: 4,
          "content-class": "vuestic-devtools__dropdown_content",
          "stick-to-edges": ""
        }, {
          anchor: withCtx(() => [
            createVNode(unref(VaButton), {
              preset: "secondary",
              icon: "add"
            })
          ]),
          default: withCtx(({ hide }) => [
            createVNode(unref(VaDropdownContent), {
              background: "backgroundElement",
              class: "app-toolbar__content"
            }, {
              default: withCtx(() => [
                createVNode(ComponentSelect, { onComponentAdded: hide }, null, 8, ["onComponentAdded"])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 1
        }),
        createVNode(unref(VaButton), {
          preset: "secondary",
          icon: "delete",
          onClick: _cache[0] || (_cache[0] = ($event) => removeComponent()),
          loading: isLoading.value
        }, null, 8, ["loading"])
      ]);
    };
  }
});
var useHoveredElement = () => {
  const { selectedAppTreeItem: selectedAppTreeItem2 } = useAppTree();
  const hoveredElement = ref(null);
  const elementHasPaddings = (el) => {
    const style = window.getComputedStyle(el);
    const paddings = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"];
    return paddings.some((padding) => parseInt(style[padding]) > 0);
  };
  const onMouseMove = (event) => {
    const elementsUnderPointer = document.elementsFromPoint(event.x, event.y).filter((el) => {
      if (!(el instanceof HTMLElement)) {
        return false;
      }
      return PREFIX in el.dataset;
    }).reverse();
    if (elementsUnderPointer.length === 0) {
      hoveredElement.value = null;
      return;
    }
    const clickedElement = elementsUnderPointer.find((el) => {
      var _a;
      if (((_a = selectedAppTreeItem2.value) == null ? void 0 : _a.el) && el.contains(selectedAppTreeItem2.value.el)) {
        return false;
      }
      const hasPaddings = elementHasPaddings(el);
      if (hasPaddings) {
        return false;
      }
      return true;
    }) ?? elementsUnderPointer[elementsUnderPointer.length - 1];
    hoveredElement.value = clickedElement;
  };
  onMounted(() => {
    window.addEventListener("mousemove", onMouseMove, { capture: true });
  });
  onBeforeMount(() => {
    window.removeEventListener("mousemove", onMouseMove, { capture: true });
  });
  return hoveredElement;
};
var MIN_ZOOM = 0.5;
var MAX_ZOOM = 2;
var useAppTransform = () => {
  const zoom = ref(1);
  const zoomIn = () => {
    if (zoom.value >= MAX_ZOOM) {
      return;
    }
    zoom.value += 0.1;
  };
  const zoomOut = () => {
    if (zoom.value <= MIN_ZOOM) {
      return;
    }
    zoom.value -= 0.1;
  };
  const onWheel = (e) => {
    if (e.deltaY > 0) {
      zoomOut();
    } else {
      zoomIn();
    }
  };
  const translate = reactive({ x: 0, y: 0 });
  let pressed = false;
  const onMouseMove = (event) => {
    if (!pressed) {
      return;
    }
    translate.x += event.movementX / zoom.value;
    translate.y += event.movementY / zoom.value;
  };
  const onMouseDown = (event) => {
    if (event.button === 2) {
      pressed = true;
    }
  };
  const onMouseUp = (event) => {
    if (event.button === 2) {
      pressed = false;
    }
  };
  const onBlur = () => {
    pressed = false;
  };
  const onContextMenu = (event) => {
    event.preventDefault();
  };
  onMounted(() => {
    window.addEventListener("blur", onBlur);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("blur", onBlur);
  });
  return {
    zoom,
    listeners: {
      wheel: onWheel,
      mousemove: onMouseMove,
      mousedown: onMouseDown,
      mouseup: onMouseUp,
      contextmenu: onContextMenu
    },
    zoomIn,
    zoomOut,
    translate
  };
};
var _sfc_main2 = defineComponent({
  __name: "Devtools",
  setup(__props) {
    const { selectAppTreeItem, selectedAppTreeItem: selectedAppTreeItem2 } = useAppTree();
    const isEditMode = ref(false);
    const { notify } = useToast();
    const { colorsToCSSVariable, colors } = useColors();
    const { zoom, translate, listeners: appTransformListeners } = useAppTransform();
    watchEffect(() => {
      if (isEditMode.value) {
        document.body.classList.add(EDIT_MODE_CLASS);
        notify({
          title: "Vuestic dev tools",
          message: 'You entered edit mode. Click on an element to inspect it. Press "ESC" to exit.',
          color: "info",
          duration: 7e3,
          position: "bottom-right"
        });
      } else {
        document.body.classList.remove(EDIT_MODE_CLASS);
      }
    });
    useEvent("keydown", (e) => {
      if (e.key === "Escape") {
        isEditMode.value = false;
        zoom.value = 1;
        translate.x = 0;
        translate.y = 0;
        selectAppTreeItem(null);
        return;
      }
      if (e.key === "F12" && e.altKey) {
        isEditMode.value = !isEditMode.value;
        zoom.value = 1;
        translate.x = 0;
        translate.y = 0;
        e.preventDefault();
        return;
      }
    }, { capture: true });
    const { element: element2 } = useComponent();
    const hoveredElement = useHoveredElement();
    function onHoveredElementClick() {
      selectAppTreeItem(hoveredElement.value);
    }
    watch(hoveredElement, (newEl, oldEl) => {
      if (oldEl) {
        oldEl.removeEventListener("dblclick", onHoveredElementClick);
      }
      if (newEl) {
        newEl.addEventListener("dblclick", onHoveredElementClick);
      }
    });
    const recalculateOutlines = useOutlines();
    watch(isEditMode, () => {
      if (isEditMode.value) {
        const LEFT_SIDEBAR_WIDTH = 300;
        const RIGHT_SIDEBAR_WIDTH = 400;
        const PADDING2 = 50;
        zoom.value = (window.innerWidth - (LEFT_SIDEBAR_WIDTH + RIGHT_SIDEBAR_WIDTH + PADDING2)) * 100 / window.innerWidth / 100;
        translate.x = LEFT_SIDEBAR_WIDTH - RIGHT_SIDEBAR_WIDTH + PADDING2;
        translate.y = 0;
      } else {
        zoom.value = 1;
        translate.x = 0;
        translate.y = 0;
      }
    });
    watch([zoom, translate], () => {
      const app = document.querySelector("#app");
      if (!app) {
        throw new Error("App element not found to zoom");
      }
      if (isEditMode.value) {
        app.style.transform = `scale(${zoom.value}) translate(${translate.x}px, ${translate.y}px)`;
      } else {
        app.style.transform = "";
      }
      nextTick(recalculateOutlines);
    }, { immediate: true });
    const elementsWithTargetVNode = computed(() => {
      var _a;
      const minifiedPath = (_a = selectedAppTreeItem2.value) == null ? void 0 : _a.ids[0];
      return [...document.querySelectorAll(`[data-${minifiedPath}]`)];
    });
    return (_ctx, _cache) => {
      return isEditMode.value ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: "body"
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(unref(colorsToCSSVariable)(unref(colors))),
          class: "vuestic-devtools"
        }, [
          createVNode(Overlay, mergeProps({ onClick: onHoveredElementClick }, toHandlers(unref(appTransformListeners))), null, 16),
          createVNode(Outline, {
            node: unref(hoveredElement),
            thickness: 1,
            dashed: ""
          }, null, 8, ["node"]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(elementsWithTargetVNode.value, (element22) => {
            return openBlock(), createBlock(Outline, {
              node: element22,
              thickness: 1,
              color: "outlineSecondary",
              background: "outlineSecondaryBackground"
            }, null, 8, ["node"]);
          }), 256)),
          createVNode(Outline, {
            node: unref(element2),
            thickness: 1,
            background: "outlinePrimaryBackground"
          }, null, 8, ["node"]),
          createVNode(_sfc_main$e, { "default-position": "top-left" }, {
            default: withCtx(() => [
              createVNode(unref(VaCard), { outlined: "" }, {
                default: withCtx(() => [
                  createVNode(_sfc_main$1)
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_sfc_main$e, {
            "default-position": "top-left",
            "offset-y": 45
          }, {
            default: withCtx(() => [
              createVNode(unref(VaCard), {
                class: "vuestic-devtools__left-sidebar",
                outlined: ""
              }, {
                default: withCtx(() => [
                  createVNode(unref(VaScrollContainer), {
                    vertical: "",
                    horizontal: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(AppTree)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          unref(element2) ? (openBlock(), createBlock(_sfc_main$e, {
            key: 0,
            "default-position": "top-right"
          }, {
            default: withCtx(() => [
              createVNode(unref(VaCard), {
                class: "vuestic-devtools__right-sidebar",
                outlined: ""
              }, {
                default: withCtx(() => [
                  createVNode(ComponentView)
                ]),
                _: 1
              })
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ], 4)
      ])) : createCommentVNode("", true);
    };
  }
});
var createVuesticDevtools = () => ({
  install(app) {
    const appRoot = document.createElement("div");
    appRoot.id = "vuestic-devtools";
    document.body.appendChild(appRoot);
    createApp(_sfc_main2).use(createVuestic({
      config: {
        colors: {
          variables: {
            outlinePrimary: "#00b4d8",
            outlineSecondary: "#90e0ef",
            outlinePrimaryBackground: "#00b4d811",
            outlineSecondaryBackground: "#90e0ef01",
            backgroundToolbar: "#252422"
          }
        }
      }
    })).mount(appRoot);
  }
});
export {
  createVuesticDevtools
};
//# sourceMappingURL=@vuestic_compiler_devtools.js.map
