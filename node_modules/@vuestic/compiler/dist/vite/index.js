"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// vite-plugin/index.ts
var vite_plugin_exports = {};
__export(vite_plugin_exports, {
  vuestic: () => vuestic
});
module.exports = __toCommonJS(vite_plugin_exports);

// ../../node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// vite-plugin/index.ts
var import_vite2 = require("vite");

// devtools/plugin/plugin.ts
var import_vite = require("vite");
var import_pluginutils = require("@rollup/pluginutils");

// devtools/plugin/compiler.ts
var import_compiler_sfc = require("@vue/compiler-sfc");
var import_magic_string = __toESM(require("magic-string"));

// devtools/shared/CONST.ts
var PREFIX = "va";
var API_PREFIX = "/vuestic-devtools-api";

// devtools/shared/slug.ts
var knownPaths = /* @__PURE__ */ new Map();
var minifyPath = (path) => {
  const minified = `${PREFIX}-${knownPaths.size}`;
  knownPaths.set(minified, path);
  return minified;
};
var unminifyPath = (minified) => {
  if (knownPaths.has(minified)) {
    return knownPaths.get(minified);
  }
  return null;
};
var replacePath = (minified, path) => {
  knownPaths.set(minified, path);
  return minified;
};

// devtools/shared/file-query.ts
var stringifyFileQuery = (path, start, end) => `${path}:${start}:${end}`;
var parseFileQuery = (query) => {
  const params = query.split(":");
  const end = params.pop();
  const start = params.pop();
  const path = params.join(":");
  return { path, start: Number(start), end: Number(end) };
};

// devtools/plugin/compiler.ts
var walk = (node, cb) => {
  cb(node);
  if (!("children" in node)) {
    return;
  }
  for (const child of node.children) {
    if (typeof child === "string") {
      continue;
    }
    if (typeof child === "symbol") {
      continue;
    }
    if (child.type === 4) {
      continue;
    }
    walk(child, cb);
  }
};
var findEndTagIndex = (source) => {
  let inQuotes = false;
  for (let i = 0; i < source.length; i++) {
    if (source[i] === '"') {
      inQuotes = !inQuotes;
    }
    if (source[i] === ">" && !inQuotes) {
      return i;
    }
  }
  return -1;
};
var findSefCloseTagIndex = (source) => {
  let inQuotes = false;
  for (let i = 0; i < source.length; i++) {
    if (source[i] === '"') {
      inQuotes = !inQuotes;
    }
    if (source[i] === "/" && source[i + 1] === ">" && !inQuotes) {
      return i;
    }
  }
  return -1;
};
var getNodeTagLoc = (source) => {
  let selfCloseIndex = findSefCloseTagIndex(source);
  let closeIndex = findEndTagIndex(source);
  if (selfCloseIndex === -1) {
    selfCloseIndex = source.length;
  }
  if (closeIndex === -1) {
    closeIndex = source.length;
  }
  return {
    start: { offset: 0 },
    end: { offset: selfCloseIndex < closeIndex ? selfCloseIndex + 2 : closeIndex + 1 },
    source: source.slice(0, selfCloseIndex < closeIndex ? selfCloseIndex + 2 : closeIndex + 1),
    endSymbol: selfCloseIndex < closeIndex ? "/>" : ">"
  };
};
var transformFile = async (code, id) => {
  var _a;
  const result = (0, import_compiler_sfc.parse)(code);
  const templateAst = (_a = result.descriptor.template) == null ? void 0 : _a.ast;
  if (!templateAst) {
    return;
  }
  let source = new import_magic_string.default(code);
  walk(templateAst, (node) => {
    if (node.type === 1) {
      const tagLoc = getNodeTagLoc(node.loc.source);
      const nodeId = stringifyFileQuery(id, node.loc.start.offset, node.loc.end.offset);
      const withAttribute = ` data-${PREFIX}="" data-${minifyPath(nodeId)}="${node.tag}"`;
      source.appendLeft(node.loc.start.offset + tagLoc.end.offset - tagLoc.endSymbol.length, withAttribute);
    }
  });
  return {
    code: source.toString(),
    map: source.generateMap()
  };
};

// devtools/server/utils.ts
var readBody = async (req) => {
  return new Promise((resolve2) => {
    let body = "";
    req.on("data", (chunk) => {
      body += chunk;
    });
    req.on("end", () => {
      resolve2(body);
    });
  });
};

// devtools/server/file.ts
var import_promises = require("fs/promises");
var requestSource = async (path) => {
  const source = await (0, import_promises.readFile)(path, "utf-8");
  return source.toString();
};
var getIntent = (source, lineStart) => {
  let intent = 0;
  for (let i = lineStart - 1; i > 0; i--) {
    if (source[i] === " ") {
      intent++;
    } else {
      break;
    }
  }
  return intent;
};
var removeIntent = (source, intent) => {
  const lines = source.split("\n");
  const intentString = " ".repeat(intent);
  return lines.map((line) => {
    if (line.startsWith(intentString)) {
      return line.slice(intentString.length);
    }
    return line;
  }).join("\n");
};
var addIntent = (source, intent) => {
  if (source.length === 0) {
    return source;
  }
  const lines = source.split("\n");
  const intentString = " ".repeat(intent);
  return lines.filter((line) => line.length > 0).map((line, index) => {
    if (index === 0) {
      return line;
    }
    return intentString + line;
  }).join("\n");
};
var getComponentSource = async (path, start, end) => {
  const fileSource = await requestSource(path);
  const intent = getIntent(fileSource, start);
  const componentSource = fileSource.slice(start, end);
  return removeIntent(componentSource, intent);
};
var setComponentSource = async (path, start, end, source) => {
  const fileSource = await requestSource(path);
  const intent = getIntent(fileSource, start);
  const sourceWithIntent = addIntent(source, intent);
  const fileSourceStart = fileSource.slice(0, start);
  const fileSourceEnd = fileSource.slice(end);
  const newFileContent = fileSourceStart + sourceWithIntent + fileSourceEnd;
  await (0, import_promises.writeFile)(path, newFileContent);
  return {
    path,
    start,
    end: start + sourceWithIntent.length
  };
};
var deleteComponentSource = async (path, start, end) => {
  const fileSource = await requestSource(path);
  const intent = getIntent(fileSource, start);
  if (intent === 0) {
    await (0, import_promises.writeFile)(path, fileSource.slice(0, start) + fileSource.slice(end));
    return {
      path,
      start,
      end: start
    };
  }
  const fileSourceStart = fileSource.slice(0, start - intent - "\n".length);
  const fileSourceEnd = fileSource.slice(end);
  await (0, import_promises.writeFile)(path, fileSourceStart + fileSourceEnd);
  return {
    path,
    start: start - intent - "\n".length,
    end: start - intent - "\n".length
  };
};
var getComponentLineAndCol = async (path, start) => {
  const fileSource = await requestSource(path);
  const intent = getIntent(fileSource, start);
  const lines = fileSource.slice(0, start).split("\n");
  const line = lines.length;
  const col = intent;
  return { line, col };
};
var getRelativeFilePath = (path) => {
  return "." + path.replace(process.cwd(), "");
};

// devtools/server/server-middleware.ts
var devtoolsServerMiddleware = () => {
  return async (req, res, next) => {
    if (!req.url || !req.url.startsWith(API_PREFIX)) {
      return next();
    }
    const url = new URL(req.url, "http://localhost:8088");
    const minified = url.searchParams.get("q") ?? "";
    const unminified = unminifyPath(minified);
    if (!unminified) {
      res.writeHead(400);
      res.end(`No q provided. Got q="${url.searchParams.get("q")}"`);
      return;
    }
    const { path, start, end } = parseFileQuery(unminified);
    if (req.method === "GET" && req.url.startsWith(`${API_PREFIX}/node-source`)) {
      res.writeHead(200);
      res.end(await getComponentSource(path, start, end));
      return;
    }
    if (req.method === "PATCH" && req.url.startsWith(`${API_PREFIX}/node-source`)) {
      const body = await readBody(req);
      if (!(typeof body === "string")) {
        throw new Error("Body is required.");
      }
      const newPath = await setComponentSource(path, start, end, body);
      replacePath(minified, stringifyFileQuery(newPath.path, newPath.start, newPath.end));
      res.writeHead(200);
      res.end(minified);
      return;
    }
    if (req.method === "DELETE" && req.url.startsWith(`${API_PREFIX}/node-source`)) {
      const newPath = await deleteComponentSource(path, start, end);
      replacePath(minified, stringifyFileQuery(newPath.path, newPath.start, newPath.end));
      res.writeHead(200);
      res.end();
      return;
    }
    if (req.method === "GET" && req.url.startsWith(`${API_PREFIX}/file-name`)) {
      res.writeHead(200);
      res.end(unminified);
      return;
    }
    if (req.method === "GET" && req.url.startsWith(`${API_PREFIX}/relative-file-path`)) {
      res.writeHead(200);
      res.end(getRelativeFilePath(path));
      return;
    }
    if (req.method === "GET" && req.url.startsWith(`${API_PREFIX}/vscode-path`)) {
      const { line, col } = await getComponentLineAndCol(path, Number(start));
      res.writeHead(200);
      res.end(`${path}:${line}:${col}`);
      return;
    }
    next();
  };
};

// devtools/plugin/plugin.ts
var import_node_url = require("url");

// devtools/plugin/add-vue-plugin.ts
var import_magic_string2 = __toESM(require("magic-string"));
var CREATE_APP_TEMPLATE = "createApp(App)";
var addVuePlugin = (code) => {
  const ms = new import_magic_string2.default(code);
  const createAppIndex = code.indexOf(CREATE_APP_TEMPLATE);
  if (createAppIndex === -1) {
    return null;
  }
  ms.appendRight(createAppIndex + CREATE_APP_TEMPLATE.length, ".use(createVuesticDevtools())");
  ms.appendLeft(0, 'import { createVuesticDevtools } from "@vuestic/compiler/devtools";\n');
  return {
    code: ms.toString(),
    map: ms.generateMap({ hires: true })
  };
};

// shared/color.ts
var white = "\x1B[0m";
var reset = "\x1BRESET";
var red = "\x1B[31m";
var yellow = "\x1B[33m";
var cyan = "\x1B[36m";
var formatString = (str) => {
  str = str.replace(/\[([^\]]*)\]/g, (_, p1) => cyan + p1 + reset);
  if (str.startsWith("!!! ")) {
    str = red + str.slice(4).replaceAll(reset, red) + reset;
  }
  if (str.startsWith("! ")) {
    str = yellow + str.slice(2).replaceAll(reset, yellow) + reset;
  }
  return str.replaceAll(reset, white);
};

// devtools/plugin/plugin.ts
var ALT_KEY = process.platform === "darwin" ? "Option \u2325" : "Alt";
var logger = (0, import_vite.createLogger)("info", {
  prefix: "[vuestic:devtools]"
});
var devtools = (options = {}) => {
  const filter = (0, import_pluginutils.createFilter)(
    options.include ?? ["**/*.vue"],
    options.exclude ?? ["node_modules/**"]
  );
  let config;
  return {
    name: "vuestic:devtools",
    configureServer(server) {
      server.middlewares.use(devtoolsServerMiddleware());
    },
    configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    async resolveId(id) {
      if (id.startsWith("@vuestic/compiler/devtools")) {
        if (config.isProduction) {
          throw new Error("VuesticDevtools: devtools must not be imported in production");
        }
        return (0, import_node_url.fileURLToPath)(new import_node_url.URL("../client/index.ts", importMetaUrl));
      }
    },
    transform(code, id) {
      if (config.isProduction) {
        return;
      }
      if (/\/src\/main\.(ts|js|mjs|mts)$/.test(id)) {
        const newCode = addVuePlugin(code);
        if (newCode) {
          logger.info(formatString(`Vuestic Devtools installed. Open your application and press [${ALT_KEY}] + [F12] to open devtools`), {
            timestamp: true
          });
        } else {
          logger.error(formatString("! Devtools plugin can not find createApp(App) in your main file. This is likely a bug, please, open an issue on GitHub."), {
            timestamp: true
          });
          logger.error(formatString("[https://github.com/epicmaxco/vuestic-ui/issues/new?assignees=&labels=BUG&projects=&template=bug-template.md]"), {
            timestamp: true
          });
        }
        return newCode;
      }
      if (!filter(id)) {
        return;
      }
      return transformFile(code, id);
    }
  };
};

// css-layers/plugin.ts
var import_magic_string3 = __toESM(require("magic-string"));
var addLayer = (ms, layer) => {
  ms.prepend(`@layer ${layer} {
`);
  ms.append(`
}`);
  return {
    code: ms.toString(),
    map: ms.generateMap()
  };
};
var cssLayers = {
  name: "vuestic:css-layer",
  transform(code, id) {
    if (!id.endsWith(".css"))
      return null;
    if (id.includes("vuestic-ui/dist/styles/")) {
      return addLayer(new import_magic_string3.default(code), "vuestic.styles");
    }
    if (id.includes("vuestic-ui/dist/es/")) {
      return addLayer(new import_magic_string3.default(code), "vuestic.components");
    }
  }
};

// vuestic-config/plugins/config-resolver.ts
var import_node_fs = require("fs");
var import_promises2 = require("fs/promises");
var VUESTIC_CONFIG_ALIAS = "#vuestic-config";
var resolveVuesticConfigPath = () => {
  if ((0, import_node_fs.existsSync)("./vuestic.config.ts")) {
    return "./vuestic.config.ts";
  } else if ((0, import_node_fs.existsSync)("./vuestic.config.js")) {
    return "./vuestic.config.js";
  } else if ((0, import_node_fs.existsSync)("./vuestic.config.mjs")) {
    return "./vuestic.config.mjs";
  } else if ((0, import_node_fs.existsSync)("./vuestic.config.cjs")) {
    return "./vuestic.config.cjs";
  } else if ((0, import_node_fs.existsSync)("./vuestic.config.mts")) {
    return "./vuestic.config.mts";
  } else {
    return void 0;
  }
};
var tryToReadConfig = async (path) => {
  if ((0, import_node_fs.existsSync)(path)) {
    return (0, import_promises2.readFile)(path, "utf-8");
  }
  return null;
};
var isConfigExists = (configPath) => {
  if (!configPath) {
    return resolveVuesticConfigPath();
  }
  return (0, import_node_fs.existsSync)(configPath);
};
var configResolver = (options = {}) => {
  return {
    name: "vuestic:config-resolver",
    // Resolve vuestic config alias
    async resolveId(source) {
      if (source === VUESTIC_CONFIG_ALIAS) {
        return `virtual:vuestic-config`;
      }
    },
    async load(id) {
      const {
        configPath = resolveVuesticConfigPath()
      } = options;
      if (id === `virtual:vuestic-config`) {
        if (!configPath) {
          return "export default {}";
        }
        const config = await tryToReadConfig(configPath);
        if (config) {
          return config;
        } else if (options.configPath) {
          throw new Error(`Vuestic config file not found at ${configPath}`);
        } else {
          "export default {}";
        }
      }
    }
  };
};

// shared/plugin/is-entry-file.ts
var isEntryFile = (id) => {
  return /\/src\/main\.(ts|js|mjs|mts)$/.test(id);
};

// shared/plugin/js.ts
var import_magic_string4 = __toESM(require("magic-string"));

// shared/plugin/code.ts
var import_acorn = require("acorn");
var getContentInParenthesis = (content) => {
  let text = "";
  let bracketCount = 0;
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "(") {
      bracketCount++;
      continue;
    }
    if (content[i] === ")") {
      bracketCount--;
    }
    if (bracketCount === 0) {
      break;
    }
    text += content[i];
  }
  return text;
};
var isObject = (t) => {
  return t.type === "ObjectExpression";
};
var isProperty = (t) => {
  return t.type === "Property";
};
var OBJECT_DECLARATION = "const obj = ";
var replaceOrAddConfigPropertyValue = (content, newValue) => {
  const code = OBJECT_DECLARATION + content;
  try {
    const program = (0, import_acorn.parse)(code, { ecmaVersion: 2020 });
    const object = program.body[0].declarations[0].init;
    let configProperty = null;
    if (isObject(object)) {
      const properties = object.properties;
      for (const property of properties) {
        if (isProperty(property)) {
          const name = "name" in property.key ? property.key.name : "value" in property.key ? property.key.value : null;
          if (name === "config") {
            configProperty = property;
            break;
          }
        }
      }
      if (!configProperty) {
        return `{
          config: ${newValue},
          ${properties.map((p) => {
          var _a;
          return (_a = p.loc) == null ? void 0 : _a.source;
        }).join(", ")}
        }`;
      }
      return (code.slice(0, configProperty.start) + `config: ` + newValue + code.slice(configProperty.end)).slice(OBJECT_DECLARATION.length);
    }
    return content;
  } catch (e) {
    console.error("Unable to parse code:", code);
    console.error(e);
    return content;
  }
};

// shared/plugin/js.ts
var createMagicString = (code) => {
  return typeof code === "string" ? new import_magic_string4.default(code) : code;
};
var addImport = (originalCode, code) => {
  const ms = createMagicString(originalCode);
  ms.appendLeft(0, code + "\n");
  return ms;
};
var mergeVuesticPluginConfigOption = (originalCode, pluginName, content = "") => {
  const ms = createMagicString(originalCode);
  const createPluginCode = `.use(${pluginName}(`;
  const existingPluginIndex = ms.original.indexOf(createPluginCode);
  if (existingPluginIndex === -1) {
    return null;
  }
  const nextCode = ms.original.slice(existingPluginIndex + createPluginCode.length - 1);
  const contentInParenthesis = getContentInParenthesis(nextCode);
  let newCode;
  if (contentInParenthesis) {
    newCode = replaceOrAddConfigPropertyValue(contentInParenthesis, content);
  } else {
    newCode = `{ config: ${content} }`;
  }
  return ms.remove(existingPluginIndex, existingPluginIndex + createPluginCode.length + contentInParenthesis.length + 2).appendLeft(existingPluginIndex + createPluginCode.length, `.use(${pluginName}(${newCode}))`);
};
var compileCode = (ms) => {
  if (typeof ms === "string") {
    return { code: ms };
  }
  return {
    code: ms.toString(),
    map: ms.generateMap()
  };
};

// vuestic-config/plugins/use-config.ts
var CONFIG_IMPORT_NAME = "vuesticConfig$va1";
var useConfig = (options = {}) => {
  return {
    name: "vuestic:use-config",
    transform(code, id) {
      if (!isEntryFile(id)) {
        return;
      }
      if (!isConfigExists(options.configPath)) {
        return;
      }
      let newCode = addImport(code, `import ${CONFIG_IMPORT_NAME} from '#vuestic-config'`);
      const createVuestic = mergeVuesticPluginConfigOption(newCode, "createVuestic", CONFIG_IMPORT_NAME);
      const createVuesticEssential = mergeVuesticPluginConfigOption(newCode, "createVuesticEssential", CONFIG_IMPORT_NAME);
      if (createVuestic) {
        return compileCode(createVuestic);
      }
      if (createVuesticEssential) {
        return compileCode(createVuesticEssential);
      }
      throw new Error("createVuestic or createVuesticEssential not found");
    }
  };
};

// vuestic-config/plugins/config-types.ts
var import_promises3 = require("fs/promises");
var import_path = require("path");
var typeModule = (configPath) => {
  return `
import config from '${configPath}';
import { PartialGlobalConfig, type IconConfiguration } from 'vuestic-ui';

type ExtractColorNames<T extends PartialGlobalConfig> = T['colors'] extends { variables: infer U } ? keyof U : never
type ExtractIconNames<T extends PartialGlobalConfig> = T['icons'] extends IconConfiguration<infer U>[] ? U : never
type ExtractI18nKeys<T extends PartialGlobalConfig> = keyof T['i18n']


type Config = typeof config

type ColorNames = ExtractColorNames<Config>

declare module 'vuestic-ui' {
  export interface CustomColorVariables extends Record<ColorNames, string> {}
}

type IconNames = ExtractIconNames<Config>

declare module 'vuestic-ui' {
  export interface CustomIconVariables extends Record<IconNames, string> {}
}

type I18nKeys = ExtractI18nKeys<Config>

declare module 'vuestic-ui' {
  export interface CustomI18NKeys extends Record<I18nKeys, string> {}
}
`.trim();
};
var configTypes = (options = {}) => {
  return {
    name: "vuestic:config-types",
    async buildStart() {
      let configPath = options.configPath || resolveVuesticConfigPath();
      if (!configPath) {
        return;
      }
      configPath = (0, import_path.resolve)(configPath);
      const module2 = typeModule(configPath);
      await (0, import_promises3.mkdir)("node_modules/.vuestic", { recursive: true });
      await (0, import_promises3.writeFile)("node_modules/.vuestic/config.d.ts", module2, {
        encoding: "utf-8",
        flag: "w"
      });
    }
  };
};

// vuestic-config/plugin.ts
var vuesticConfig = (options = {}) => {
  return [
    configTypes(options),
    configResolver(options),
    useConfig(options)
  ];
};

// shared/merge-deep.ts
var isObject2 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject2(target)) {
    target = {};
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (sourceValue instanceof RegExp || sourceValue instanceof Date) {
      target[key] = sourceValue;
    } else if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = mergeDeep(Object.create(
        Object.getPrototypeOf(targetValue),
        Object.getOwnPropertyDescriptors(targetValue)
      ), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};

// vite-plugin/index.ts
var logger2 = (0, import_vite2.createLogger)("info", {
  prefix: "[vuestic:compiler]"
});
var defaultOptions = {
  devtools: false,
  cssLayers: false,
  config: {
    configPath: "vuestic.config.ts"
  }
};
var vuestic = (options = {}) => {
  options = mergeDeep(defaultOptions, options);
  const extractOptions = (key) => {
    return typeof options[key] === "object" ? options[key] : void 0;
  };
  const plugins = [];
  if (options.devtools !== false) {
    logger2.info("Using vuestic:devtools", {
      timestamp: true
    });
    plugins.push(devtools(extractOptions("devtools")));
  }
  if (options.cssLayers !== false) {
    logger2.info("Using vuestic:css-layers", {
      timestamp: true
    });
    plugins.push(cssLayers);
  }
  if (Boolean(options.config)) {
    logger2.info("Using vuestic:config", {
      timestamp: true
    });
    plugins.push(...vuesticConfig(extractOptions("config")));
  }
  return plugins;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  vuestic
});
